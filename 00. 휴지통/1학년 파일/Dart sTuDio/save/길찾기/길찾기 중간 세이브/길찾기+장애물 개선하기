w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 5'.split()
r = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 5'.split()
w[0],r[0] = [5] * 2
w[20],r[16] = [4] * 2
for i in range(1,20):
    w[i] = ord(w[i])
    if i < 16: r[i] = ord(r[i])

def write(ad,val):
    ser = serial_open(port = 'COM')
    w[14] = ord(str(ad // 10))
    w[15] = ord(str(ad % 10))
    if val < 16:
        w[18] = ord(str(0))
        w[19] = ord(hex(val)[2]) 
    else:
        w[18] = ord(hex(val)[2])
        w[19] = ord(hex(val)[3])
    ser.write(bytearray(w))
    serial_close(ser)
    wait(0.02)

def read(ad):
    ser = serial_open(port = 'COM')
    r[14] = ord(str(ad // 10))
    r[15] = ord(str(ad % 10))
    ser.write(bytearray(r))
    wait(0.02)
    r1 = ser.read(ser.inWaiting())
    r2 = r1.decode()
    sum = int(r2[10:14],16)
    return sum

#=====================(측정)========================
drl_report_line(ON)
set_velx(300), set_accx(300)#전역속도설정

a = add = a0 = a1 = a2 = count = leng = length = fr = 0
lenbox = [0,0]
move = 1
yv = [0,0];  xv = [0,0]; yxbox = [0,0];  dead_road =[0,0]; road1 = [0,0]; road2 = [0,0]; yx = [0,0]
cl = [0] * 4; BOX = [0] * 4; clbox = [0] * 4 ; BOXa = [0] * 4; write_ = [0] * 16
global dead_road
XU = [posx(138.81, 279.71, 55, 62.47, 180, 62.72)]*48

for x in range(1,48):
    if x%8 != 0:
        XU[x] = trans(XU[x-1], [-40,0,0,0,0,0], 0, 0)
    else:
        XU[x] = trans(XU[x-8], [0,40,0,0,0,0], 0, 0)

A = [[9]*10 for _ in range(8)]
for y in range(1,7):
    for x in range(1,9):
        A[y][x] = 0        
B = []
for i in A:
    B.append(i[:])
    
A0 = A[0]
A1 = A[1]
A2 = A[2]
A3 = A[3]
A4 = A[4]
A5 = A[5]
A6 = A[6]
A7 = A[7]

for y in range(1,7):
    for x in range(1,9):
        if B[y][x] == 0: 
            B[y][x] = XU[a]
            a = a+1
        if read((y-1)*8+x) == 1+add:
            yv[0+a0] = y
            xv[0+a0] = x    
        if read((y-1)*8+x) == 3:
            A[y][x] = 9
            a1 = a1 + 1
        if yv[0] != 0 and xv[0] != 0:
            add = 1; a0 = 1
            
def seting():
    movel([0,0,100,0,0,0], mod = 1);
    movela = B[yv[0]][xv[0]]
    start = trans(movela, [0,0,105,0,0,0], 0, 0)
    movel(start)
    movel([0,0,-105,0,0,0], mod = 1)
    A[yv[0]][xv[0]] = 1    
    
def HMIset():
    a  = 0
    for i in range(1,48):
        if read(i) == 3:
            write_[a] = i
            a += 1
#===================(계 산)========================
seting()
#HMIset()
# 1. 갈 수 있는 길 찾기 
def find(c): 
    cl,a = [0] * 4,0
    global cl, count
    for i in range(4):
        if i % 2 == 0:
            a = 1
            if i < 2:   b = -1
            else:   a,b = 0, 1
        else:
            a = -1
            if i < 2:   b = 1
            else:   a,b = 0,-1
        if A[yv[0]+a][xv[0]+b+a] == c:
            cl[i] = 1
 
#3. 갈림길 해결사☆  ex) BOX(Current location) = [1,0,1,0]
def len_():
    a = b = c = count_ = trueDR = DRT = o = stop_ = DR = RT = n = R = r = 0
    global length, count_,cl ,trueDR, dead_road, sb, DRT, RT, BOXa
    for _ in range(2):
        a += 1
        for i in range(4):# 갈림길중 하,상,우,좌 순으로 한개를 정하고 지움
            if BOX[i] == 1:
                BOX[i] = 0 # 읽은 값은 삭제
                if i == 0:  yv[0] += 1
                elif i == 1:    yv[0] -= 1
                elif i == 2:    xv[0] += 1
                elif i == 3:    xv[0] -= 1
                A[yv[0]][xv[0]] = a + 1                
                break
        while True:            
            find(0)
            #======(조건)=========
            count_ = 0
            for i in range(4):#0~3
                if cl[i] == 1:  count_ += 1
            if cl == [0] * 4: #갈 곳이 없을때 탈출 
                if yv[0] == yv[1]:  dead_road[a-1] = 0
                if a == 1:
                    road1[0] = yv[0]
                    road1[1] = xv[0]
                if a == 2:
                    road2[0] = yv[0]
                    road2[1] = xv[0]
                yv[0] = yxbox[0]
                xv[0] = yxbox[1]                
                break
            if count_ >= 2: #갈림길일때 탈출
                if a == 1:
                    road1[0] = yv[0]
                    road1[1] = xv[0]
                if a == 2:
                    road2[0] = yv[0]
                    road2[1] = xv[0]
                yv[0] = yxbox[0]
                xv[0] = yxbox[1]                
                break
            #====================
            for i in range(4):
                if cl[i] == 1:
                    if i == 0:
                        yv[0] += 1
                    elif i == 1:
                        yv[0] -= 1
                    elif i == 2:
                        xv[0] += 1
                    elif i == 3:
                        xv[0] -= 1
                    A[yv[0]][xv[0]] = a + 1                    
    a = 0 # a reset 
    for i in range(2):
        if dead_road[i] == 1:
            trueDR = 1
            b = i
            break
    if trueDR == 0:
        while DRT == 0 and RT == 0:
            for i in range(2):  
                o += 1
                if i == 0:
                    yv[0] = road1[0]
                    xv[0] = road1[1]
                elif i == 1:
                    yv[0] = road2[0]
                    xv[0] = road2[1]
                while stop_ == 0:
                    for i in range(4):
                        find(0) 
                        if cl[i] == 1:
                            if i == 0:  yv[0] += 1
                            elif i == 1:    yv[0] -= 1
                            elif i == 2:    xv[0] += 1
                            elif i == 3:    xv[0] -= 1
                        A[yv[0]][xv[0]] = 4
                        yx[0] = yv[0] # 4를 찍은 좌표 저장 
                        yx[1] = xv[0]
                        find(0)
                        if cl != [0] * 4:
                            yv[0] = yx[0]
                            xv[0] = yx[1]
                    
                    if yv[0] == yv[1] and xv[0] == xv[1]: # 도착 지점일때 
                        if o == 1:
                            yv[0] = road2[0]
                            xv[0] = road2[1]
                            A[yv[0]][xv[0]] =  8   
                        if o == 2:
                            yv[0] = road1[0]
                            xv[0] = road1[1]
                            A[yv[0]][xv[0]] =  8                            
                        yv[0] = yxbox[0]
                        xv[0] = yxbox[1]
                        RT = 1
                        break
                    if cl == [0] * 4: # 막혔을때 
                        if o == 1:
                            yv[0] = road1[0]
                            xv[0] = road1[1]
                            A[yv[0]][xv[0]] =  8
                        elif o == 2:
                            yv[0] = road2[0]
                            xv[0] = road2[1]
                            A[yv[0]][xv[0]] =  8    
                        yv[0] = yxbox[0]
                        xv[0] = yxbox[1]
                        DRT = 1
                        break
                if DRT == 1 or RT == 1:
                    break
            yv[0] = yxbox[0]
            xv[0] = yxbox[1]
            find(0)
            break
    
    if trueDR == 1:
        for i in range(4):
            if clbox[i] == 1:
                c += 1
            if c == b + 1:
                if i == 0:
                    yv[0] += 1
                elif i == 1:
                    yv[0] -= 1
                elif i == 2:
                    xv[0] += 1
                elif i == 3:
                    xv[0] -= 1
                A[yv[0]][xv[0]] = 8
                yv[0] = yxbox[0]
                xv[0] = yxbox[1]
                find(0)
                break               
         
    for y in range(1,7):
        for x in range(1,9):
            if A[y][x] == 2:
                A[y][x] = 0
            if A[y][x] == 3:
                A[y][x] = 0                    
            if A[y][x] == 4:
                A[y][x] = 0 


#4. 이동 *갈림길이면 돌아감* 
while True:
    A[yv[0]][xv[0]] = 1 # 시작 위치 표시 
    find(0)#Current location[0,0,0,0]~[1,1,1,1] [1,0,1,0]
    for i in range(4):#0~3
        if cl[i] == 1:
            count += 1
    if count >= 2:# 2. 갈림길인지 확인 하기
        yxbox[0] =yv[0]# 두 갈래길 좌표 저장
        yxbox[1] =xv[0]
        BOX = cl 
        clbox = BOXa = [0] * 4
        dead_road = [0,0]
        trueDR = 0
        for i in range(4):
            if cl[i] == 1:
                clbox[i] = 1
                BOXa[i] = 1
        len_()# 3. 돌아감
    count = 0
    #============(이동부)=================
    for i in range(4):
        if cl[i] == 1:
            if i == 0:
                yv[0] += 1
            elif i == 1:
                yv[0] -= 1
            elif i == 2:
                xv[0] += 1
            elif i == 3:
                xv[0] -= 1
    movel(B[yv[0]][xv[0]])
    if yv[0] == yv[1] and xv[0] == xv[1]:
        A[yv[0]][xv[0]] = 1
        break
    find(0)
    if cl == [0] * 4:
        for y in range(1,7):
            for x in range(1,9):
                if A[y][x] == 8:
                    A[y][x] = 0