w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 5'.split()
r = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 5'.split()
w[0],r[0] = [5] * 2
w[20],r[16] = [4] * 2
for i in range(1,20):
    w[i] = ord(w[i])
    if i < 16: r[i] = ord(r[i])

def write(ad,val):
    ser = serial_open(port = 'COM')
    w[14] = ord(str(ad // 10))
    w[15] = ord(str(ad % 10))
    if val < 16:
        w[18] = ord(str(0))
        w[19] = ord(hex(val)[2]) 
    else:
        w[18] = ord(hex(val)[2])
        w[19] = ord(hex(val)[3])
    ser.write(bytearray(w))
    serial_close(ser)
    wait(0.02)

def read(ad):
    ser = serial_open(port = 'COM')
    r[14] = ord(str(ad // 10))
    r[15] = ord(str(ad % 10))
    ser.write(bytearray(r))
    wait(0.02)
    r1 = ser.read(ser.inWaiting())
    r2 = r1.decode()
    sum = int(r2[10:14],16)
    return sum

#=====================(측정)========================

set_velx(300), set_accx(300)#전역속도설정

add = a0 = a1 = count_ = 0
a2 = 0
move = 1
yv = [0,0]; xv = [0,0]
cl = [0,0,0,0]; BOX = [0,0,0,0]
condition = 'default'

XU = [posx(138.81, 279.71, 50, 62.47, 180, 62.72)]*48

for x in range(1,48):
    if x%8 != 0:
        XU[x] = trans(XU[x-1], [-40,0,0,0,0,0], 0, 0)
    else:
        XU[x] = trans(XU[x-8], [0,40,0,0,0,0], 0, 0)

A = [[9]*10 for _ in range(8)]
for y in range(1,7):
    for x in range(1,9):
        A[y][x] = 0        
B = []
for i in A:
    B.append(i[:])
    
A0 = A[0]
A1 = A[1]
A2 = A[2]
A3 = A[3]
A4 = A[4]
A5 = A[5]
A6 = A[6]
A7 = A[7]
    
for y in range(1,7):
    for x in range(1,9):
        if B[y][x] == 0: 
            B[y][x] = XU[a2]
            a2 = a2+1
        if read((y-1)*8+x) == 1+add:
            yv[0+a0] = y
            xv[0+a0] = x    
        if read((y-1)*8+x) == 3:
            A[y][x] = 9
            a1 = a1 + 1
        if yv[0] != 0 and xv[0] != 0:
            add = 1
            a0 = 1

#===================(계 산)========================

# 1. 갈 수 있는 길 찾기 
def find(): 
    global cl, count_
    at = 0
    for i in range(4):
        if i % 2 == 0:            
            at = 1
            if i < 2:
                b = -1
            else: 
                at = 0
                b = 1
        else:
            at = -1
            if i < 2:
                b = 1
            else:
                at = 0
                b = -1
        if A[yv[0]+at][xv[0]+b+at] == 0:
            cl[i] = 1


#3. 갈림길 해결사☆  ex) BOX(Current location) = [1,0,1,0]
def len_(BOX): 
    length = 0
    for i in range(4): 
        if cl[i] == 1:
            count_ += 1 # 갈림길 갯수 = count_
    for _ in range(count_):
        while cl != [0,0,0,0]:
            if i == 0:
                A[yv[0]+1][xv[0]]
            if i == 1:
                A[yv[0]-1][xv[0]]
            if i == 2:
                A[yv[0]][xv[0]+1]
            if i == 3:
                A[yv[0]][xv[0]-1]
            cl = [0] * 4
            find()
            
#main()
while True:
    wait(0.2)
    find()#Current location[0,0,0,0]~[1,1,1,1]
    for i in range(4):#0~3
        if cl[i] == 1:# 2. 갈림길인지 확인 하기
            count_ += 1
            if count_ >= 2:
                condition = '갈림길'
                len_(cl)
        count_ = 0
             
