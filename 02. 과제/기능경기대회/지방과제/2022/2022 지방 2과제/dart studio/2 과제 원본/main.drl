drl_report_line(OFF)

w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 4'.split()
r = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 4'.split()
wP,rP = w[:],r[:]
wP[11:21] = 'P X 0 0 0 0 0 4'.split()
rP[11:17] = 'P X 0 0 0 4'.split()

w[0],r[0],wP[0],rP[0] = [5] * 4
w[20],wP[18],r[16],rP[16] = [4] * 4                

wr = lambda x : list(map(lambda f : ord(f), x[1:len(x)-1]))
for i in [w,r,wP,rP]:
    i[1:len(i)-1] = wr(i)

def write(ad, val, sk = 0):
    ser = serial_open(port = "COM")
    wP[13] = w[13] = ord(str(ad//100))
    wP[14] = w[14] = ord(str((ad%100)//10))
    wP[15] = w[15] = ord(str(ad%10))
    wP[16] = w[18] = ord(str(0)) if val < 16 else ord(hex(val)[2])
    wP[17] = w[19] = ord(hex(val)[2]) if val < 16 else ord(hex(val)[3])
    ser.write(bytearray(wP if sk else w))
    serial_close(ser)
    wait(0.02)

def read(ad , sk = 0):
    ser = serial_open(port = "COM")
    rP[13] = r[13] = ord(str(ad//100))
    rP[14] = r[14] = ord(str((ad%100)//10))
    rP[15] = r[15] = ord(str(ad%10))
    ser.write(bytearray(rP if sk else r))
    wait(0.02)
    r1 = ser.read(ser.inWaiting())
    r2 = r1.decode()
    return r2[11] if sk else int(r2[10:14],16)
    
#***
speed = 2022
set_velx(speed); set_accx(speed)    
#P O S X 
A = [posx(327.98, 320.06, 185, 90, 180, 0)] * 10
B = [posx(58.03, 378.17, 185, 90, 180, 0)] * 6
C = [posx(-171.48, 280.22, 185, 90, 180, 0)] * 24

# Apal
for i in range(1,10):
    if i in [2,4,8]: A[i] = trans(A[i-2],[0,40,0,0,0,0])
    else: A[i] = trans(A[i-1],[-40,0,0,0,0,0])
    if i == 6: A[i] = trans(A[1],[-40,0,0,0,0,0])
# Bpal  
for i in range(1,6): 
    if i == 4: B[i] = trans(B[i-4],[-40,40,0,0,0,0])
    else: B[i] = trans(B[i-1],[-40,0,0,0,0,0])
# Cpal
for i in range(1,24):
    if i == 12: C[i] = trans(C[2],[-40,0,0,0,0,0])
    else:
        if i % 3 == 0:  C[i] = trans(C[i-3],[0,40,0,0,0,0])
        else: C[i] = trans(C[i-1],[-40,0,0,0,0,0])        

#보드에 숫자 넣기
def read_board(board):
    num = [1,1,2,2]
    for i in range(4):
        board[board.index(0)] = num[i]
    
# 변수  
C_1 = [read(i) for i in range(1,10)] # 실제 파레트
C_3 = [read(i) for i in range(13,22)]
goal_br = C_1[:] #Goal board state (미리 계산용)
br = C_3[:]  # board state
read_board(br) # 미리 값넣기

li_1 = []; li_2 = []; li_3 = [] # serch result list

B_pack = [1 if read(i) == 3 else 0 for i in range(35,39)] # B_index_3
door_state = 1 if read(40) == 3 else 0  # now door open? or close?
up_pos = [[0,0,5,0,0,0],[0,0,38,0,0,0],[0,0,65,0,0,0]]#up_poslist
A_2 = [read(i) for i in range(29,35)]# A_2 list
A_1 = [0] * 4 # A_1 list
C_2 = [0] * 3; C_4 = [0] * 3
way_point = posx(-6.15, 453.53, 275.82, 116.59, -179.99, 106.59) # A to C

br_box = []; br_box_2 = []; recode = [] #astar and list
G = 1;F = []; #astar
#board serch ***

#random
def mr(board):
    count = 0; result = [0] * 9
    for i in [3,2,1,6,5,4,9,8,7]:
        result[count] = board[i-1]
        count+=1
    return result

#astar & random
def recoding_board():
    global br,recode
    re_id = br[:] # id가 겹쳐서 re_id를 겹침
    recode.append(re_id) # 노드를 저장함
    
#astar(calulating huristic)
def comparing_board(): 
    start = [0] * 2; arrival = [0] * 2; length = [];
    y = [1,1,1,2,2,2,3,3,3]; x = [1,2,3,1,2,3,1,2,3]
    sum_ = 0 ; count = 0 
    global goal_br,br,count_,g
    for i in range(9):
        if br[i] != goal_br[i]: # 목표 위치에 없으면 
            start = [y[i],x[i]] # 맨해튼 출발 지점
            num = br[i] # 현재 위치 숫자
            if num == 0: continue # 예 외 숫자 (0, 3??)            
            for l in [6,3,0,7,4,1,8,5,2]:
                if goal_br[l] == num: # 목표 지점을 찾으면
                    arrival = [y[l],x[l]] # 맨해튼 도착 지점
                    length.append(abs(start[0] - arrival[0]) + abs(start[1] -arrival[1]))
            sum_ += min(length)
    F.append(G + sum_)# F 값 저장 
    br_box.append(br)# 보드 저장

#astar   
def comparing_cases():
    global goal_br,br
    box = br[:] #box -> br
    for i in range(9):
        if br[i] == 0:
            for arr in [-3,3,-1,1]:
                if i in [2,5] and arr == 1: continue
                if i in [3,6] and arr == -1: continue             
                dire = i + arr
                if dire > -1 and dire < 9 and br[dire] != 0: # 0 ~ 8
                    box_0 = br[dire] # box_0 -> br[dire]
                    br[dire] = br[i] # br[dire] -> br[i]
                    br[i] = box_0 # br[i] -> box_0(br[dire])
                    comparing_board() # f(x)
                    br = box[:]

#astar & random
def comparing_cases_2(br,get,fix_3 = "false"):
    global goal_br
    box = br[:] #box -> br
    for i in range(9):
        if br[i] == 0:
            for arr in [-3,3,-1,1]:
                if i in [2,5] and arr == 1: continue
                if i in [3,6] and arr == -1: continue             
                dire = i + arr
                if dire > -1 and dire < 9 and br[dire] != 0: # 0 ~ 8
                    if fix_3 == "true":
                        if br[dire] == 3: continue
                    a = br[dire] # a -> br[dire]
                    br[dire] = br[i] # br[dire] -> br[i]
                    br[i] = a # br[i] -> a(br[dire])
                    get.append(br[:]) # 저장
                    br = box[:] #br -> box
                    
def reset():
    global br_box,br_box_2,recode,F,G
    del br_box[:]
    del br_box_2[:]
    del recode[:]
    del F[:]
    G = 1
                    
#astar
def Optimizing():
    global recode,br_box_2
    new_recode = []; save = []
    start = recode[0] # 시작 지점 저장
    recode = recode[::-1]# reverse(arrival -> start)
    li = recode[0] # 초기값
    new_recode.append(li[:]) # 초기 값 저장
    while li != start:
        comparing_cases_2(li,br_box_2)
        for i in recode[recode.index(li)+1:]:
            if i in br_box_2: save.append(i)
        li = save[-1] # 다음 비교 보드
        new_recode.append(li[:]) # 새 기록에 저장
    tp_log("complete !!! step: {}".format(len(new_recode)-1))
    return new_recode[::-1]
    
# astar
def select_board_astar(): 
    global br,F,br_box
    a = 0
    while True:
        a += 1
        for i in range(len(F)):
            if F[i] == a and br_box[i] not in recode:
                br = br_box[i] # 다음 노드
                recoding_board() # 노드 기록
                return -1
                
#random
def select_board():
    global br,br_box, recode
    for i in br_box:
        if i not in recode:
            br = i # 다음 보드
            recoding_board() # 보드 저장
            break
            
#astar & random (이자식이 변수도 초기화 해줌
def converter(li):
    new_li = []
    for i in range(len(li)):
        for l in range(9):
            if li[i][l] == 0 and li[i+1][l] != 0: a = l
            if li[i+1][l] == 0 and li[i][l] != 0: b = l
        new_li.append(b)
        new_li.append(a)
        if li[i+1] == li[len(li)-1]: 
            reset() # 사용 했던 모든 변수 초기화
            return new_li

def astar():
    global goal_br,br,G
    recoding_board() # 보드 기록
    while goal_br != br:
        G += 1
        comparing_cases() # 각 경우의 수의 f(x)
        select_board_astar() # 노드 선택      
        del F[:]; del br_box[:] # reset 
    return Optimizing()
    
def random_serch():
    global goal_br,br
    goal_br = mr(goal_br)
    recoding_board() # 저장
    while goal_br != br:
        comparing_cases_2(br, br_box,"true") # 지금 보드에서 한 칸 움직여 가능한 보드를 보여줌
        select_board() # 보드 선택
    return Optimizing() # 최적화

# ========= robot ========= ***
printf = lambda n: tp_log("{}".format(n)) # tp_log !!!
# buzz !!!z = lambda n: write(100,n)

# 그리퍼
def grip(a):
    wait(0.1)
    set_tool_digital_outputs([1*a,2*-a])
    wait(0.1)
    
# z 축이 n보다 낮으면 n 까지 올리기
def up(n):    
    now_pos = get_desired_posx()
    if now_pos[2] < n: movel([0,0,n - now_pos[2],0,0,0],mod = 1)
    
#1: close / 0: open
def open_close(n):
    global door_state
    if door_state == n: return -1
    begin_blend(2)
    door_state = n
    a = 5 if n == 0 else 4
    movel(trans(B[a],up_pos[1]))
    movel(B[a])
    grip(1)
    write(int(1560/(39+n)),0) # 39 open / 40 close
    movec(trans(B[int(20/a)],[0,0,2,0,0,0]),B[int(20/a)],1800,1800)
    grip(-1)
    buzz(2)
    write(39+n,3)
    movel(trans(B[int(20/a)],up_pos[1]))

def up_down(next_floor):
    begin_blend(2)
    now_floor = B_pack.index(1)
    if now_floor == next_floor-1: return -1
    open_close(1)
    B_pack[now_floor] = 0
    movel(trans(B[now_floor],up_pos[1]))
    movel(B[now_floor])
    grip(1)
    write(35+now_floor,0)
    movec(trans(B[next_floor-1],[0,0,1,0,0,0]),B[next_floor-1],1800,1800)
    grip(-1)    
    write(34+next_floor,3)
    B_pack[next_floor-1] = 1
    movel(trans(B[next_floor-1],up_pos[1]))
    open_close(0)
    
    
# 팩 놓기 
def put_pack():
    begin_blend(10)
    global A_1,C_4
    for i in range(2):
        now_pack = A_1[1-i]
        if i == 0:movel(trans(A[7-i],up_pos[1]))
        else: movec(way_point,trans(A[7-i],up_pos[1]))
        movel(A[7-i])
        grip(1)
        write(26-i,0)
        A_1[1-i] = 0
        movel(trans(A[7-i],up_pos[2]))
        if now_pack != 3: 
            movec(way_point,trans(C[12+C_3.index(0)],up_pos[2])) #왼쪽 위부터 팩이 없는곳
            movel(C[12+C_3.index(0)]) # 밑으로
            grip(-1)
            write(13+C_3.index(0),now_pack) # HMI
            C_3[0+C_3.index(0)] = now_pack
        else:   # 3 팩일때 
            movec(way_point,trans(C[21+C_4.index(0)],up_pos[2]))
            movel(C[21+C_4.index(0)])
            grip(-1)
            write(22+C_4.index(0),now_pack)
            C_4[C_4.index(0)] = now_pack
        movel(up_pos[1], mod = 1)    
    
#팩 싣기, 옮기기 
def load_pack(): 
    begin_blend(10)
    global A_2,C_2
    next_floor = [0] * 6
    int_list = [3,1,3,1,2,2]
    A_2_copy = A_2[:]
    for i in range(6):
        a =  A_2_copy.index(int_list[i])
        A_2_copy[a] = 0
        next_floor[i] = 4 if a in [0,1] else 3 if a in [2,3] else 2
    for i in [0,2,4]: # next_floor = 4,2,4,2,3,3
        for l in range(2):
            up_down(next_floor[i+l]) #[0,1/2,3/4,5]  
            index_pos = A_2.index(int_list[i+l])
            movel(trans(A[index_pos],up_pos[1]))
            movel(A[index_pos])
            grip(1)
            write(29+index_pos,0) # HMI
            A_2[index_pos] = 0
            my_seat = 6+A_1.index(0) # 7 ~ 10 승강기 빈 자리
            movec(trans(A[my_seat],[0,0,40,0,0,0]),A[my_seat],1200,1200)            
            grip(-1)
            write(my_seat+19,int_list[i+l])
            A_1[A_1.index(0)] = int_list[i+l]
            movel(trans(A[my_seat],up_pos[1]))
        up_down(1) # 1층으로
        put_pack() # 0 ~ 1
    for i in [[35,36,37,38],[39,40]]:
        for l in range(len(i)):
            if read(i[l]) == 3:
                movel(trans(B[i[l]-35],up_pos[1]))
                movel(B[i[l]-35])
                grip(1)
                write(i[l],0)
                movel(trans(B[i[l]-35],up_pos[2]))  
                movel(trans(C[9+C_2.index(0)],up_pos[2]))
                movel(C[9+C_2.index(0)])
                grip(-1)
                write(10+C_2.index(0),3)
                C_2[C_2.index(0)] = 3
                movel(up_pos[1],mod = 1)
                break    
                
def serch():
    start = t.time()
    global li_1,li_2,li_3,br,goal_br
    li_1 = converter(random_serch()) # C - 3 거울 배치    
    goal_br = [1,1,1,2,2,2,3,0,0]
    li_2 = converter(astar()) # C - 3 재배치   
    br = C_1[:]
    li_3 = converter(astar()) # C - 1 재배치
    tp_log("ready !!! {} sec".format(round(t.time() - start,2)))
                
def solving_puzzle():
    begin_blend(2)
    global li_1,li_2,li_3,C_1,C_3
    count = maintain = 0
    # 거울 배치, C - 3 재배치, C - 1 재배치
    list_ =  [li_1,li_3,li_2]
    err = [12,0,12] # 오차
    for li in list_: # 거울 배치. 재 배치
        for j in range(0,len(li),2):
            now = err[count]+li[j] # 옮길 팩 위치 = 오차 + 현재 위치 
            next = err[count]+li[j+1]  # 옮길 위치 = 오차 + 다음 위치
            if maintain == 0: # 유지
                movel(trans(C[now],up_pos[1])) # 현재 위치 위에가서  
                movel(C[now]) # 내려가 
                grip(1) # 잡아 
                num = read(now+1) # 잡은 팩 값을 받아 
            else: 
                maintain = 0
            write(now+1,0) # 그리고 원래 자리에 값 지워
            movec(trans(C[next],[0,0,1,0,0,0]),C[next]) # 깡총 
            if len(li) > j+2 and li[j+1] == li[j+2]: 
                maintain = 1
                continue 
            grip(-1) # 뱉어 
            write(next+1,num) # 아까 저장한 겂을 적어
            movel(trans(C[next],up_pos[1])) # 위로 올라와
        count += 1 # 오차를 바꿔줄 카운트
        if li == li_1:
            buzz(2)
            wait(0.31)
            buzz(2)
    for i in [[9,7],[10,8],[21,19],[22,20]]: # 마지막 3팩 이동
        movel(trans(C[i[0]],up_pos[1]))
        movel(C[i[0]])
        grip(1)
        write(i[0]+1, 0)
        if i in [[9,7],[10,8]]:
            movec(trans(C[i[1]],[0,0,1,0,0,0]),C[i[1]])
        else:
            movel(trans(C[i[0]],up_pos[2]))
            movel(trans(C[i[1]],up_pos[2]))
            movel(C[i[1]])
        grip(-1)
        write(i[1]+1,3)
        movel(trans(C[i[1]],up_pos[1]))
    buzz(3) # 완성 부저
            
def test():
    grip(-1) # grip off
    up(300)
    movel(trans(B[0],up_pos[1]))
    serch() # 보드 계산
    begin_blend(5)
    while True:
        if get_digital_input(1) == 0: continue
        buzz(1)# 0.5
        load_pack() # 팩 옮기기
        solving_puzzle() # 정렬
        return "complete"    
# ***
mute = "OFF" # 부저 뮤트
test()
