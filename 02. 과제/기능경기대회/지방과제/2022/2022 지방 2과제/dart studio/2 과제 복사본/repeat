drl_report_line(OFF)
printf = lambda a: tp_log("{}".format(a))

w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 4'.split()
r = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 4'.split()
w[0],r[0] = [5] * 2
w[-1],r[-1] = [4] * 2

for i in [w,r]:
    i[1:-1] = list(map(lambda a: ord(a),i[1:-1]))
    
def write(ad,val):
    ser = serial_open(port = 'COM')
    w[13] = ord(str(ad//100))
    w[14] = ord(str((ad%100)//10))
    w[15] = ord(str(ad%10))
    w[18] = ord(str(0)) if val < 16 else ord(hex(val)[2])
    w[19] = ord(hex(val)[2]) if val < 16 else ord(hex(val)[3])
    ser.write(bytearray(w))
    serial_close(ser)
    wait(0.02)
    
def read(ad):
    ser = serial_open(port = 'COM')
    r[13] = ord(str(ad//100))
    r[14] = ord(str((ad%100)//10))
    r[15] = ord(str(ad%10))
    ser.write(bytearray(r))
    wait(0.02)
    n = int(ser.read(ser.inWaiting()).decode()[10:14],16)
    serial_close(ser)
    return n
    
A = [posx(328.78, 321.93, 185, 90, 180, 0)] * 10
B = [posx(58.03, 380.68, 185, 90, 180, 0)] * 6
C = [posx(-171.48, 280.22, 185, 90, 180, 0)] * 24

up_pos = [[0,0,0.5,0,0,0],[0,0,38,0,0,0],[0,0,65,0,0,0]]
way_point = posx(0,450,300,90,180,0)

for_li = [0,1,6,7,2,3,8,9,4,5]
for i in for_li:
    count = for_li.index(i)
    if count == 0: continue
    if count % 4 == 0: A[i] = trans(A[for_li[count-4]],[0,40,0,0,0,0])
    else: A[i] = trans(A[for_li[count-1]],[-40,0,0,0,0,0])
for i in range(1,6):
    if i == 4: B[i] = trans(B[1],[0,40,0,0,0,0])
    else: B[i] = trans(B[i-1],[-40,0,0,0,0,0])
for i in range(1,24):
    if i == 12: C[i] = trans(C[2],[-40,0,0,0,0,0])
    else:
        if i % 3 == 0: C[i] = trans(C[i-3],[0,40,0,0,0,0])
        else: C[i] = trans(C[i-1],[-40,0,0,0,0,0])
        
A_1 = [0] * 4
A_2 = [read(i) for i in range(29,35)]
B_1 = [1,0,0,0]
B_2 = 1
C_1 = [read(i) for i in range(1,10)]
C_3 = [read(i) for i in range(13,22)]
C_2 =  [9,0,0]
C_4 = [9,0,0]

def read_board(li):
    for i in [1,1,2,2]: li[li.index(0)] = i
    
goal_br = C_1[:]
br = C_3[:]
read_board(br)
serch_result = [0] * 3
recode = []; br_list = []; br_list2 = []
F = []; G = 1

mr = lambda li: [li[i-1] for i in [3,2,1,6,5,4,9,8,7]]
recoding = lambda li: recode.append(li[:])

def MHT():
    mht = []; result = 0
    y = [1,1,1,2,2,2,3,3,3]; x = [1,2,3,1,2,3,1,2,3]
    for i in range(9):
        if br[i] != goal_br[i] and br[i] != 0:
            s = [y[i],x[i]]
            for j in range(9):
                if br[i] != goal_br[j]:
                    a = [y[j],x[j]]
                    mht.append(abs(s[0]-a[0])+abs(s[1]-a[1]))
            result += min (mht)
    F.append(G + result); br_list.append(br)
    
def cases(board, serch, fix3, get):
    if board == "global": global br
    else: br = board[:]
    save = br[:]
    for i in range(9):
        if br[i] == 0:
            for j in [-3,3,-1,1]:
                dire = i+j
                if i in [2,5] and j == 1: continue    
                if i in [3,6] and j == -1: continue
                if -1 < dire < 9 and br[dire] != 0:
                    if fix3 == "true" and br[dire] == 3: continue
                    br[i] = br[dire]
                    br[dire] = 0
                    if serch == "astar": MHT()
                    else: get.append(br)
                    br = save[:]
                    
def reset():
    del recode[:], br_llst[:], br_list2[:],F[:]
    G = 1
    
def Optimizing():
    global recode
    new_recode = []; result = []
    recode = recode[::-1]
    br = recode[0]
    new_recode.append(br)
    while br != recode[-1]:
        cases(br,"Optimizing","false",br_list2)
        for i in recode[recode.index(br):]:
            if i in br_list2: result.append(i)
        br = result[-1]
        new_recode.append(br)
    printf("step: {}".format(len(new_recode)-1))
    return new_recode[::-1]
    
def select_astar(count = 0):
    global br
    while True:
        count += 1
        for i in range(len(F)):
            if F[i] == count and br_list[i] not in recode:
                br = br_list[i]
                recoding(br)
                return -1
                
def select_random():
    global br
    for i in br_list:
        if i not in recode:
            br = i
            recoding(br)
            return -1
            
def converter(li):
    new_li = []
    for i in range(len(li)):
        if len(li) <= 1: return -1
        for j in range(9):
            if li[i+1][j] == 0 and li[i][j] != 0: a = j
            if li[i][j] == 0 and li[i+1][j] != 0: b = j
        new_li.append(a)
        new_li.append(b)
        if li[i+1] == li[-1]:
            return new_li
            
def astar():
    global br,goal_br, G
    recoding(br)
    while br != goal_br:
        G += 1
        cases("global","astar","false",[])
        select_astar()
        del F[:],br_list[:]
    return Optimizing()

def random_serch():
    global br,goal_br
    recoding(br)
    goal_br = mr(goal_br)
    while br != goal_br:
        cases("global","randome","true",br_list)
        select_random()
    return Optimizing()
    
set_velx(2000); set_accx(1500)

buzz = lambda a: write(50,a)

def grip(a, ad = -1, val = -1):
    wait(0.1)
    set_tool_digital_outputs([1*n,2*-n])
    if - 1 not in [ad,val]: write(ad, val)
    wait(0.05)
    
def moves(pos, ad = -1, val = -1):
    movel(trans(pos,up_pos[1]))
    movel(pos)
    grip(1, ad, val)
    
def movea(pos, ad = -1, val = -1, bz = -1):
    grip(-1, ad, val)
    if bz != -1: buzz(bz)
    movel(trans(pos,up_pos[1]))
    
def open_close(n):
    global B_2
    if B_2 == n: return -1
    B_2 = n
    