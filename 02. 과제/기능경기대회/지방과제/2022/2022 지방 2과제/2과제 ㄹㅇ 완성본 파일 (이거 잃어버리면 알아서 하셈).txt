drl_report_line(OFF)
printf = lambda a: tp_log("{}".format(a))

w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 4'.split()
r = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 4'.split()
w[0],r[0] = [5] * 2
w[-1],r[-1] = [4] * 2

for i in [w,r]:
    i[1:-1] = list(map(lambda a: ord(a),i[1:-1]))
    
def write(ad, val):
    ser = serial_open(port = 'COM')
    w[13] = ord(str(ad//100))
    w[14] = ord(str((ad%100)//10))
    w[15] = ord(str(ad%10))
    w[18] = ord(str(0)) if val < 16 else ord(hex(val)[2])
    w[19] = ord(hex(val)[2]) if val < 16 else ord(hex(val)[3])
    ser.write(bytearray(w))
    serial_close(ser)
    wait(0.02)
    
def read(ad):
    ser = serial_open(port = 'COM')
    r[13] = ord(str(ad//100))
    r[14] = ord(str((ad%100)//10))
    r[15] = ord(str(ad%10))
    ser.write(bytearray(r))
    wait(0.02)
    n = int(ser.read(ser.inWaiting()).decode()[10:14],16)
    serial_close(ser)
    return n
    
A = [posx(328.78, 321.93, 185, 90, 180, 0)] * 10
B = [posx(58.03, 380.68, 185, 90, 180, 0)] * 6
C = [posx(-171.48, 280.22, 185, 90, 180, 0)] * 24

for_li = [0,1,6,7,2,3,8,9,4,5]
for i in for_li:
    count = for_li.index(i)
    if count == 0: continue
    if count % 4 == 0: A[i] = trans(A[for_li[count-4]],[0,40,0,0,0,0])
    else: A[i] = trans(A[for_li[count-1]],[-40,0,0,0,0,0])

for i in range(1,6):
    if i == 4: B[i] = trans(B[1],[0,40,0,0,0,0])
    else: B[i] = trans(B[i-1],[-40,0,0,0,0,0])

for i in range(1,24):
    if i == 12: C[i] = trans(C[2],[-40,0,0,0,0,0])
    else:
        if i % 3 == 0: C[i] = trans(C[i-3],[0,40,0,0,0,0])
        else: C[i] = trans(C[i-1],[-40,0,0,0,0,0])
    
A_1 = [0] * 4
A_2 = [read(i) for i in range(29,35)]
B_1 = [1,0,0,0]
B_2 = 1
C_1 = [read(i) for i in range(1,10)]
C_3 = [read(i) for i in range(13,22)]
C_2 = [9,0,0]
C_4 = [9,0,0]

up_pos = [[0,0,0.5,0,0,0],[0,0,38,0,0,0],[0,0,65,0,0,0]]
way_point = posx(0,450,300,90,180,0)

def read_board(li):
    for i in [1,1,2,2]: li[li.index(0)] = i
    return li
    
goal_br = C_1[:]
br = C_3[:]
read_board(br)
serch_result = [0]* 3
recode = []; br_list =[]; br_list2 = []
F = []; G = 1

mr = lambda li: [li[i-1] for i in [3,2,1,6,5,4,9,8,7]]
recoding = lambda li: recode.append(li[:])

def MHT():
    mht = []; result = 0
    y = [1,1,1,2,2,2,3,3,3]; x = [1,2,3,1,2,3,1,2,3]
    for i in range(9):
        if br[i] != goal_br[i] and br[i] != 0:
            s = [y[i],x[i]]
            for j in range(9):
                if goal_br[j] == br[i]:
                    a = [y[j],x[j]]
                    mht.append(abs(s[0]-a[0])+abs(s[1]-a[1]))
            result += min(mht)
    F.append(G + result); br_list.append(br)
    
def cases(board, serch, fix3, get):
    if board == "global": global br
    else: br = board[:]
    save = br[:]
    for i in range(9):
        if br[i] == 0: 
            for j in [-3,3,-1,1]:
                dire = i + j
                if i in [2,5] and j == 1: continue
                if i in [3,6] and j == -1: continue
                if -1 < dire < 9 and br[dire] != 0:
                    if fix3 == "true" and br[dire] == 3: continue
                    br[i] = br[dire]
                    br[dire] = 0
                    if serch == "astar": MHT()
                    else: get.append(br)
                    br = save[:]
                
def reset():
    del recode[:],br_list[:],br_list2[:],F[:]
    G = 1
    
def Optimizing():
    global recode
    new_recode = []; result = []
    recode = recode[::-1]
    br = recode[0]
    new_recode.append(br[:])
    while br != recode[-1]:
        cases(br,"Optimizing","false",br_list2)
        for i in recode[recode.index(br):]:
            if i in br_list2: result.append(i)
        br = result[-1]
        new_recode.append(br)
    printf("step: {}".format(len(new_recode)-1))
    return new_recode[::-1]
    
def select_astar(count = 0):
    global br
    while True:
        count += 1
        for i in range(len(F)):
            if F[i] == count and br_list[i] not in recode:
                br = br_list[i]
                recoding(br)
                return -1

def select_random():
    global br
    for i in br_list:
        if i not in recode:
            br = i
            recoding(br)
            return -1
            
def converter(li):
    new_li = []
    if len(li) == 1: return -1
    for i in range(len(li)):
        for j in range(9):
            if li[i+1][j] == 0 and li[i][j] != 0: a = j
            if li[i][j] == 0 and li[i+1][j] != 0: b = j
        new_li.append(a)
        new_li.append(b)
        if li[i+1] == li[-1]:
            return new_li
            
def astar():
    global goal_br,br,G
    recoding(br)
    while goal_br != br:
        G += 1
        cases("global","astar","false",[])
        select_astar()
        del F[:],br_list[:]
    return Optimizing()
    
def random_serch():
    global goal_br, br
    recoding(br)
    goal_br = mr(goal_br)
    while goal_br != br:
        cases("global","random","true",br_list)
        select_random()
    return Optimizing()

set_velx(2000); set_accx(1500)

buzz = lambda a: -1 #write(50,a)

def grip(n, ad = -1, val = -1):
    wait(0.1)
    set_tool_digital_outputs([1*n,2*-n])
    if -1 not in [ad,val]: write(ad,val)
    wait(0.05)
    
def moves(pos, ad = -1, val = -1):
    movel(trans(pos,up_pos[1]))
    movel(pos)
    grip(1, ad, val)
    
def movea(pos , ad = -1, val = -1, bz = -1):
    grip(-1, ad, val)
    if bz != -1: buzz(bz)
    movel(trans(pos,up_pos[1]))
    
def open_close(n):
    global B_2
    if B_2 == n: return -1
    B_2 = n
    moves(B[5-n], 40 - n, 0)
    movec(trans(B[4+n],[0,5,5,0,0,0]),trans(B[4+n],up_pos[0]),2000,1200)
    movea(B[4+n], 39 +n, 3,2)
   
def up_down(n):
    _next = n- 1
    _now = B_1.index(1)
    if _next == _now: return -1    
    open_close(1)
    moves(B[_now], 35+_now, 0)
    movec(trans(B[_next],[0,-5,5,0,0,0]),trans(B[_next],up_pos[0]),2000,1200)
    movea(B[_next], 35+_next, 3)
    B_1[_now] = 0
    B_1[_next] = 1
    open_close(0)
    
def put_pack():
    for i in range(2):
        pack = A_1[1-i]
        if i == 0: movel(trans(A[7-i],up_pos[1]))
        else: movec(way_point,trans(A[7-i],up_pos[1]))        
        movel(A[7-i])
        grip(1, 26-i, 0)        
        c = C_4 if pack == 3 else C_3
        err = 21 if pack == 3 else 12
        movec(way_point,trans(C[err + c.index(0)],up_pos[2]))
        movel(C[err+c.index(0)])
        movea(C[err+c.index(0)], (err+1)+c.index(0), pack)
        c[c.index(0)] = pack
        A_1[1-i] = 0
       
def load_pack(num_li = [3,1,3,1,2,2]):
    for i in range(0,6,2):
        for l in range(2):
            n = A_2.index(num_li[i+l])
            f = 4 if n in [0,1] else 3 if n in [2,3] else 2
            seat = A_1.index(0)            
            up_down(f)
            moves(A[n], 29 + n, 0)
            movec(trans(A[6+seat],[0,0,40,0,0,0]),trans(A[6+seat],up_pos[0]),1200,1200)
            movea(A[6+seat], 25+seat, num_li[i+l])
            A_1[seat] = num_li[i+l]
            A_2[n] = 0
        up_down(1)
        put_pack()
    for i in range(35,41):
        if read(i) == 3:
            moves(B[i - 35], i, 0)
            movec(trans(B[i-35],[-1,0,3,0,0,0]),trans(C[9+C_2.index(0)],up_pos[2]))
            movel(C[9+C_2.index(0)])
            movea(C[9+C_2.index(0)],10+C_2.index(0), 3)
            C_2[C_2.index(0)] = 3
            
def serch(): 
    global serch_result,br,goal_br
    serch_result[0] = converter(random_serch())
    reset()
    br = mr(C_1[:]); goal_br = [1,1,1,2,2,2,3,0,0]
    serch_result[2] = converter(astar())
    reset() 
    br = C_1[:]
    serch_result[1] = converter(astar())
    printf("ready")
    
def solving_puzzle():
    maintain = 0; count = -1
    err = [12,0,12]
    for li in serch_result:
        count += 1
        if li == -1: continue
        for i in range(0,len(li),2):
            s = err[count]+li[i]
            a = err[count]+li[i+1]
            num = read(s+1)
            if maintain == 0: moves(C[s])
            else: maintain = 0
            write(s+1,0)
            movec(trans(C[a],[0,0,1,0,0,0]),C[a],2000,1200)
            if i+2 < len(li): 
                if li[i+2] != li[i+1]: movea(C[a])
                else: maintain = 1; wait(0.15)
            else: movea(C[a])
            write(a+1, num)
        if count == 0: 
            buzz(2)
            wait(0.31)
            buzz(2)
    for i in [10,11,22,23]:
        moves(C[i], i+1, 0)
        movec(trans(C[i-3],[0,0,1,0,0,0]),C[i-3],1200,1200)
        movea(C[i-3],i-2, 3)    
    
def test():
    begin_blend(10)
    grip(-1)
    movej([90,0,90,0,90,0],40,40)
    movel(trans(B[0],up_pos[1]))
    serch()
    while 1:
        if get_digital_input(1) == 0: continue
        buzz(1)
        load_pack()
        solving_puzzle()
        buzz(3)
        return -1
        
test()