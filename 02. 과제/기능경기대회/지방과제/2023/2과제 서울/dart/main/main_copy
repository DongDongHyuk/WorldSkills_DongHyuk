drl_report_line(OFF)
from collections import deque
import time # ***
tl = lambda *n: tp_log(' '.join(map(str,n)))

def exc(n,s,e):
    n = list(n)
    n[s],n[e] = n[e],'0'
    return ''.join(n)

def exp(mode,n,pos = None):
    res = []
    dxy = [-5,1,5,-1]
    wall = [[0,1,2,3,4],[4,9,14,19,24],[20,21,22,23,24],[0,5,10,15,20]]
    li = [i for i in range(len(n)) if n[i] == '0' and i not in fix] if mode else [pos]
    for pos in li:
        for i in range(4):
            npos = pos + dxy[i]
            if pos not in wall[i] and \
               n[npos] not in [['9'],['9','0']][mode] and npos not in fix:
                res.append(exc(n,pos,npos) if mode else npos)
    return res

def bfs(mode,n,*args):
    if not mode:
        s,e = args
    else:
        li = args[0]
    cur = n if mode else s
    que = deque([cur])
    mkd = {cur:'s'}
    while 1:
        cur = que.popleft()
        if (not mode and cur == e) or \
           (mode and not any([int(cur[i]) for i in li])):
            break
        for  i in exp(mode,cur if mode else n,cur):
            if i not in mkd:
                mkd[i] = cur
                que.append(i)
    mkd['e'] = cur
    return (mkd,cur) if mode else mkd

def path(mkd):
    cur = mkd['e']
    path = [cur]
    while mkd[cur] != 's':
        cur = mkd[cur]
        path.append(cur)
    return path[::-1][1:]

def con(res):
    path = []
    fir = res[0]
    for sec in res[1:]:
        step = [None] * 2
        for i in range(len(sec)):
            if fir[i] != sec[i]:
                if fir[i] == '0':
                    step[1] = i
                else:
                    step[0] = i
        path.append(step)
        fir = sec[::]
    return path

def main(mode,n,*args):
    global fix
    n = ''.join(n)
    fix = []
    if not mode:
        s,e = args
        res = [s]
        res += path(bfs(mode,n,s,e))
        return res
    else:
        li,fp = args
        if fp:
            fix.append(fp)
        res = [n]
        for i in range(1,len(li)+1):
            mkd,n = bfs(mode,n,li[0:i])
            res += path(mkd)
        return con(res),list(n)

w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 4'.split()
r = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 4'.split()
w[0],r[0] = [5] * 2
w[-1],r[-1] = [4]  * 2

for i in [w,r]:
    i[1:-1] = map(ord,i[1:-1])
    
def write(ad,val,abs=1):
    val += (10 * (gate.index(ad) + 1)  if abs != -1 and ad in gate else 0)
    ser = serial_open(port = 'COM')
    w[13] = ord(str(ad//100))
    w[14] = ord(str((ad%100)//10))
    w[15] = ord(str(ad%10))
    w[18] = ord('0') if val < 16 else ord(hex(val)[2])
    w[19] = ord(hex(val)[2]) if val < 16 else ord(hex(val)[3])
    ser.write(bytearray(w))
    serial_close(ser)
    wait(0.02)
    
def read(ad):
    ser = serial_open(port = 'COM')
    r[13] = ord(str(ad//100))
    r[14] = ord(str((ad%100)//10))
    r[15] = ord(str(ad%10))
    ser.write(bytearray(r))
    wait(0.02)
    n = int(ser.read(ser.inWaiting()).decode()[10:14],16)
    serial_close(ser)
    return n
    
set_velx(1500); set_accx(5000)
set_velj(225); set_accj(300)
begin_blend(50)
ml,mj,mjx,aml,amj,amjx = movel,movej,movejx,amovel,amovej,amovejx
H = [150,30]
up = lambda pos,h = None: trans(pos,[0,0,(h if h else H)[isgrip],0,0,0])# 올리기
sl = lambda pos,abc = [0,0,0]: trans(pos,[0,0,0] + abc) # 기울이기 
us = lambda pos,abc,h = None: up(sl(pos,abc),h) # 올리기 + 기울이기

isgrip = False
def grip(n,ad=-1,val=-1,t = None):
    global isgrip
    if isgrip == n:
        return -1
    isgrip = 0 if n == -1 else 1
    set_tool_digital_outputs([1*n,2*-n])
    wait(t if t else (0.23 if n == 1 else 0.13))
    if -1 not in [ad,val]:
        write(ad,val)
        
def Run():   
    global gate
    grip(-1)
    
    # 좌표
    pos = [posx(-179.32, 281.56, 17, 90, 180, 0)] * 25
    for i in range(1,25):
        if i % 5: 
            pos[i] = trans(pos[i-1],[-40,0,0,0,0,0])
        else:
            pos[i] = trans(pos[i-5],[0,40,0,0,0,0]) 
    posB = [posx(338.95, 350.96, 6, 90, 115, 90),
                posx(338.88-40, 350.95-10, 6, 90, 115, 90),
                posx(338.96-80, 350.96-20, 6, 90, 115, 89.99)]

    # 파레트 정보
    br = [str(read(i)) for i in range(25)]
    gate = [None] * 5    
    for i in range(25):
        if int(br[i]) >= 10:
            gate[int(br[i][0]) - 1] = i
            br[i] = br[i][1]

    # 그리퍼 센싱
    p2p = {} # pos to pack
    ct = [0,0,0] # pack count   
    
    def update(pos,pack):
        p2p[i],br[i] = pack,str(pack)
        write(i,pack + 1)
        ct[pack - 1] += 1
        
    for i in [i for i in range(25) if br[i] == '1']:
        if len([j for j in ct if j == 3]) == 2:
            break
        mjx(up(pos[i],[50,50]),200,200,sol=2)
        for j in range(2):
            if i in p2p:
                break
            h = [20,10][j]       
            aml(up(pos[i],[h,None]), t = 0.2 if j else 0.3)
            if not j and ct[2] == 3:
                continue
            grip(1,-1,-1,0)
            wait(0.36)
            isgp = not get_tool_digital_input(1)
            pack = (2 if isgp else 1) if j else (3 if isgp else 0)
            if isgp or j:    
                update(i,pack)                
            grip(-1,-1,-1,0.18)
        ml([0,0,50,0,0,0], t = 0.3, mod = 1)
    
    pack = [i+1 for i in range(3) if ct[i] < 3][0]
    for i in range(25):
        if br[i] == '1' and i not in p2p:
            update(i,pack)
    
    B = [[],[],[]] # 적재 현황
    li = [3,3,3,2,2,2,1,1,1] # 팩 순서
    li0 = [0,0,0,1,1,1,2,2,2] # B 파래트 순서    
    li1 = main(0,''.join(br),gate[0],gate[1]) # 시작지점 -> 도착지점
    
    yx = lambda pos: divmod(pos,5)
    
    def mg(pos,n,ad,val,h = None):
        mjx(up(pos,h),sol=2)
        ml(pos)
        grip(n,ad,val)
        
    for i in range(9): 
        pack = li[i]    # 옮길 팩
        for j in range(2):
            if not j:
                e = gate[pack+1]
                ny,nx = yx(e)                
                pli = [yx(k) for k in range(25) if br[k] == str(pack)] # pack pos list                
                dli = [abs(y - ny) + abs(x - nx) for y,x in pli] # pack pos distance llist
                y,x = pli[dli.index(min(dli))]
                s = y * 5 + x
                r = main(0,br,s,e)
            else:
                g = e # 팩 점거지점
                s,e,r = gate[0],gate[1],li1[:]
                r = [k for k in r if k != g]
                
            # 경로위에 팩있으면 치우기
            res,br = main(1,br,r if j else r[1:],g if j else None) 
            
            # 정렬 과정이 없우면 궅이 다시 위로 안듬
            if j and res:
                ml([0,0,50,0,0,0],t = 0.3, mod = 1)
            
            if res:
                for k in range(len(res)):
                    S,E = res[k]
                    if not isgrip:
                        p = read(S)
                        p = int(str(p)[1]) if p >= 10 else p
                        mg(pos[S],1,S,0)
                    ml(up(pos[E]),a = 2500)
                    if k + 1 < len(res) and E == res[k + 1][0]:
                        continue
                    ml(pos[E],a = 2500)
                    grip(-1,E,p)
                    ml(up(pos[E]),a = 2500)
                    
            if j:
                 # j == 1 : 점거지점 -> 시작지점
                abc = [0,-25,0]
                #정렬과정이 있었으면 위에서 부터
                if res:
                    mjx(up(pos[g],[120,120]),sol=2)
                aml(sl(pos[g],abc))
                wait(0.2)
                grip(1,g,0)
                ml(us(pos[g],abc,[None,120]))
                ml(us(pos[s],abc,[None,120]))
                ml(us(pos[s],abc))
                br[g] = '0'
            else:
                # j == 0 :  팩 잡기
                abc = [0,0,0]
                mg(pos[s],1,s,0)
                br[s] = '0'
                
            for k in r[1:]:
                ml(us(pos[k],abc),a = 2000)
            # 시작지점 -> 점거지점에 놓기
            if not j:
                ml(pos[e],a = 2500)
                grip(-1,e,pack+1)
                br[e] = str(pack)
            
        # 팩 B에 적재
        rp = li0[i]
        aml([0,0,100,0,0,0], mod = 1)
        wait(0.1)
        mjx(up(posB[rp],[120,200]),150,550,sol = 2)
        ml(up(posB[rp],[120,20 * len(B[rp])]),a = 2500)
        wait(0.1)
        grip(-1, 25 + i, pack)
        B[rp].append(pack)
        if i != 8:
            ml([0,0,60,0,0,0],t = 0.5, mod = 1)
            amj([90,0]*3)
            wait(0.25)

write(99,1,-1)
ts = time.time()
Run()
tl('sorted in {}s'.format(round(time.time() - ts,3)))
write(99,1,-1)