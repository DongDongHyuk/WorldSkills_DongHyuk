drl_report_line(OFF)
printf = lambda *n: tp_log(' '.join(list(map(str,n))))

w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 4'.split()
r  = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 4'.split()
w[0],r[0] = [5] * 2
w[-1],r[-1] = [4] * 2

for i in [w,r]:
    i[1:-1] = map(ord,i[1:-1])
    
def write(ad,val,isabs = False):
    if not isabs: ad += (0 if Rn == 0 else 18 if Rn == 1 else 45)
    ser = serial_open(port = 'COM')
    w[13] = ord(str(ad//100))
    w[14] = ord(str((ad%100)//10))
    w[15] = ord(str(ad%10))
    w[18] = ord('0') if val < 16 else ord(hex(val)[2])
    w[19] = ord(hex(val)[2]) if val < 16 else ord(hex(val)[3])
    ser.write(bytearray(w))
    serial_close(ser)
    wait(0.02)
    
def read(ad,isabs=False):
    if not isabs: ad += (0 if Rn == 0 else 18 if Rn == 1 else 45)
    ser = serial_open(port = 'COM')
    r[13] = ord(str(ad//100))
    r[14] = ord(str((ad%100)//10))
    r[15] = ord(str(ad%10))
    ser.write(bytearray(r))
    wait(0.02)
    n = int(ser.read(ser.inWaiting()).decode()[10:14],16)
    serial_close(ser)
    return n
    
from collections import deque

def chn(board: str, now: int , new: int ):
      br = list(board) # str -> list
      br[now],br[new] = br[new],'0'
      return ''.join(br) # list -> str
    
def Truedirs(br: str):
      result = []
      n_p = [i for i in range(len(br)) if br[i] == '0' and i not in fix[1]]
      def rule(br,pos,posN):
            if Type in [0,2]:
                  return br[posN] not in fix[0] and posN not in fix[1] # fix pack,fix index
            if Type == 1:
                  if not(br[posN] not in fix[0] and posN not in fix[1]): return False # fix pack,fix index 
                  # 2층 안의 위치에 팩을 옮길때 위치 아래에 팩이 있어야됨
                  if pos >= 9 and br[pos-9] == '0': return False
                  # 1층에 있는 팩을 옮길떄 그 위치에 위에 팩이 있으면 안됨
                  if posN < 9 and br[posN+9] != '0': return False                  
                  return True                  
      rapd = result.append      
      if Type == 0: # Type 'A'
            for p in n_p:
                  for i in [-1,1,-3,3]:
                        if 0 <= p + i <= 8 and rule(br,p,p + i):
                              rapd(chn(br,p,p + i))
                              
      if Type == 1: # Type 'B'
            defult_Dirs = (-x_size,x_size,-1,1) # 상 하 좌 우
            for pos in n_p:
                  Wall = wall[pos >= 9]
                  for f in range(2): # there floor,other floor
                        n = (-9 if pos >= 9 else 9) if f else 0
                        for i,Dir in enumerate(defult_Dirs):
                              if pos not in Wall[i] and rule(br,pos,(pos+Dir)+n):
                                    rapd(chn(br,pos,(pos+Dir)+n))
      if Type == 2: # Type 'C'
            Dir = (-x_size,x_size,-1,1) # 상 하 좌 우
            for pos in n_p:
                  for i in range(4):
                        if pos not in wall[i] and rule(br,pos,pos+Dir[i]):
                              rapd(chn(br,pos,pos+Dir[i]))
      return result
                  
def bfs(root,leaf=None,idx=None,pack=None,goal_count=None):
      que = deque([root])
      marked = {root:'root'}
      br = root
      def isleaf(br): # 단말 노드일때 거짓 리턴
            if Type == 0:
                  return br != leaf
            if Type == 1:
                  if idx != None:
                        if pack != None: return br[idx] != pack
                        return br[idx] != leaf[idx]
                  if goal_count != None:
                        count = 0
                        for i in range(18):
                              if br[i] != leaf[i]: count += 1
                        return goal_count != count
                  return br != leaf
            if Type == 2:
                  if idx != None:
                        return br[idx] != leaf[idx]
                  return br != leaf
      while isleaf(br):
            br = que.popleft() # 현재 노드 
            for next_br in Truedirs(br):
                  if next_br not in marked:
                        marked[next_br] = br
                        que.append(next_br)
      marked['leaf'] = br
      if idx != None:fix[1].add(idx)
      return marked

def path(marked):
      br = marked['leaf'] # 이전 탐색의 단말 노드
      path = [br]
      while marked[br] != 'root':
            br = marked[br]
            path.append(br)
      return path[::-1]

def main(r:'root',l:'leaf',T: 'Types of Parets'):
      #Global Variables
      global root,leaf,Type,fix,wall,x_size # 고정,벽,오차
      root,leaf,Type = r,l,T
      fix = ({'0','x'},set()) # 고정 팩,고정 인덱스
      wall = [None,
            (({0,1,2},{6,7,8},{0,3,6},{2,5,8}),
            ({9,10,11},{15,16,17},{9,12,15},{11,14,17})),
            ({0,1,2,3},{12,13,14,15},{0,4,8,12},{3,7,11,15})][T]
      x_size = [None,3,4][T]      
      result = []
      
      if T == 0: # Type 'A'
            result = path(bfs(root,leaf)) # defult_bfs

      if T == 1: # Type 'B'
            marked,num_pos = {'leaf':root},[]
            
            for pos in range(9):
                  if leaf[pos] == '0':
                        num_pos.append(pos)
                        continue
                  marked = bfs(marked['leaf'],leaf,pos)
                  result += path(marked)
                  
            for pos in num_pos: 
                  Dir,Wall,pack = [-3,3,-1,1],wall[pos >= 9],None
                  for i in range(4):
                        if pos not in Wall[i] and leaf[(pos+Dir[i])+9] not in fix[0]:
                              pack = leaf[(pos+Dir[i])+9]
                              break
                  marked = bfs(marked['leaf'],leaf,pos,pack)
                  result += path(marked)
                  
            marked = bfs(marked['leaf'],leaf,None,None,4)
            result += path(marked)
            
            fix[1].clear() # fixed index reset
            fix[1].update([i for i in range(18) if marked['leaf'][i] == leaf[i]]) # fix index update            
            marked = bfs(marked['leaf'],leaf)
            result += path(marked)

      if T == 2: # Type 'C'            
            center = None
            for i in [5,6,9,10]:
                  if root[i] != 'x':
                        if leaf.index('0') in [0,3]:
                              if not(leaf.index('0') == 0 and i in [6,10]) and not(leaf.index('0') == 3 and i in [5,9]):
                                    center = i
                                    break
                        else:
                              center = i
                              break
            sorting_pos = [center + i for i in [-5,-4,-3,-1,1,3,4,5]]+[center]            
            if root.index('x') in [5,6,9,10]: # 고정팩이 해당 위치에 왔을때 우선으로 정렬할 위치
                  sequence = [[0,1,4],[3,2,7],[12,8,13],[15,11,14]][[5,6,9,10].index(root.index('x'))]
            else: sequence = []            
            li = {5:[3,12,15,7,13,11,14],
                   6:[0,15,12,4,14,8,13],
                   9:[0,15,3,1,11,2,7],
                   10:[3,12,0,2,8,4,1]}
            sequence += [i for i in li[center] if i not in sequence]
            sequence = [i for i in sequence if i not in sorting_pos]            
            marked = {'leaf':root}            
            for i in sequence:
                  marked = bfs(marked['leaf'],leaf,i)
                  result += path(marked)
            marked = bfs(marked['leaf'],leaf)
            result += path(marked)

      # list -> index
      def converter(result):
            if not len(result): return []
            first,path = result[0],[]
            for second in result[1:]:
                  step = [None,None]
                  for i in range(len(second)):
                        if first[i] != second[i]:
                              if first[i] =='0': step[1] = i
                              else: step[0] = i
                  if None not in step: path.append(step)
                  first = second[:]
            return path

      result = converter(result)
      return result

# M O V I N G
set_velx(2400); set_accx(1800); begin_blend(2.5) # Global

Positions = {0:posx(200.32, 419.95, 15.98, 90, 180, 0),
                  1:posx(379.54, 278.04, 16.31, 90, 180, 0),
                  2:posx(-320.11, 122.97, 14.55, 90, 180, 0)}
index_pos = posx(447.07, 183.45, 81.4, 0, 180, 0)

isgrip = 0
def grip(n):
    global isgrip
    if isgrip == n: return -1
    mwait(0)
    set_tool_digital_outputs([1*n,2*-n])
    if n==1: wait(0.18)
    isgrip = (0 if n == -1 else 1)
    
def posing(pos):
    x = [9,3,4][Rn]
    pos,n = [pos] * [9,18,16][Rn],50
    for i in range(1,[9,18,16][Rn]):
        if i % x: pos[i] = trans(pos[i-1],[-n,0,0,0,0,0])
        else: pos[i] = trans(pos[i-x],[0,n,0,0,0,0])
        if Rn == 1: # is 'B'
            if i == 9: pos[i] = trans(pos[i-9],[0,0,60,0,0,0])
    return pos
    
def input_br(a,b):
    p_name = [{7:'x'},{1:'4',2:'5',3:'6',4:'1',5:'2',6:'3',7:'x'}][Rn in [1,2]]
    br = [read(i) for i in range(a,b)]
    if Rn == 0: br = [p_name[i] if i in p_name else str(i) for i in br]
    if Rn == 1:
        if a == 0:
            br = ['x' if i == 7 else str(i) for i in br]
            br += br
        else: 
            br = [p_name[i] if i in p_name else str(i) for i in br]
            br = br + [p_name[int(i)] if int(i) in p_name else i for i in br]
    if Rn == 2:
        if a == 0: br = ['x' if i == 7 else str(i) for i in br]
        else:
            up = [str(i) for i in br]
            down = [p_name[i] if i in p_name else str(i) for i in br]
            br = up + up + down + down
    return ''.join(br)

#gantry
gantry_pos = 2.5
def gantry(n):
    global gantry_pos
    if n != 5: 
        write(83,1+[-1,1,-0.5,0.5].index(n),True)
        gantry_pos += n
        wait(0.35)
    else: 
        write(83,n,True)
        wait(3)
        
# index
index_li = lambda: [read(i,True) for i in range(65,73)] # index table pack list
def it(n,t = 0.5):
    write(80 if n > 0 else 81,abs(n),True)
    wait((t)*abs(n))

up_value = [[0,0,35,0,0,0],[0,0,5,0,0,0]]
up_pos = lambda: up_value[isgrip]
up = lambda pos: trans(pos,up_pos())
# 현재 좌표에서 그리퍼를 n 회전한 좌표 return
def turn(n,pos):
    global angle
    angle = n
    return [pos[0],pos[1],pos[2],[0,90][n],180,0]

pass_stack,val = 0,0
def move(start,end,ispass = False,h_limit = [35,5]):
    global pass_stack,val,up_value # 패스 스택, 통신값
    for ct,i in enumerate((start,end)):    
        if i == None:
            if pass_stack != 0: pass_stack -= 1 
            continue            
        up_value = [[0,0,h_limit[0],0,0,0],[0,0,h_limit[1],0,0,0]]
        if Rn == 1 and i < 9: up_value[0][2] += 60 # B
        Pos = turn(angle,pos[i]) if Rn == 2 else pos[i]        
        if not pass_stack: movel(up(Pos))
        if ct and ispass: pass_stack += 2 # 현재 스텝 끝, 다음 스텝 시작 pass        
        if pass_stack == 0:
            if not ct: val = read(i) # 잡을 팩
            movel(Pos,None,[1400,800][up_value[0][2] <= 35])
            if Rn == 1 and i > 8: # B, 2층에 팩을 쌓을때 하단 팩의 높이에 맞춰야됨
                under_value = (20 if read(i-9) in [1,4] else 0 if read(i-9) in [2,5] else 10)
                movel([0,0,-under_value,0,0,0],None,800,mod = 1)
            else: under_value = 0
            grip(-1 if ct else 1)
            write(i,val if ct else 0)
            movel(up(Pos),None,[1400,800][up_value[0][2] <= 35])
        else: pass_stack -= 1

def Run(Type:int):
    global Rn,pos,gantry_pos,val
    Rn = Type # Running_now
    root = input_br(0,9) if Type == 0 else input_br(0,9) if Type == 1 else input_br(0,16)
    leaf = input_br(9,18) if Type == 0 else input_br(18,27) if Type == 1 else input_br(16,20)
    if Rn in [1,2]: leaf = ''.join(['x' if root[i] == 'x' else leaf[i] for i in range(len(leaf))])
    pos = posing(Positions[Type]) # 파테트 좌표 찍기    
    Path = main(root,leaf,Type) # 정렬 알고리즘
    
    if Type == 0: # A
        gantry(-0.5) # 반 칸
        movel(trans(pos[Path[0][0]],[0,0,35,0,0,0]))
        for i in range(len(Path)):
            start,end = Path[i]
            ispass = i+1 <  len(Path) and Path[i+1][0] == end            
            if start - end in [-3,3]: # 3 칸 이동 
                goal_gantry_pos = (start if start < end else end)
                # 겐트리 무빙
                while goal_gantry_pos != gantry_pos:
                    if gantry_pos < goal_gantry_pos: gantry(+1)
                    else: gantry(-1)
                if not isgrip:
                    movel(up(pos[start]))
                    movel(pos[start])
                    grip(1)
                    val = read(start) # global val
                    write(start,0)
                movel([0,0,25,0,0,0],mod = 1)
                movel([0,150,0,0,0,0],mod = 1)                
                movel([150 if start - end > 0 else -150,0,0,0,0,0],mod = 1)
                movel([0,-150,0,0,0,0],mod = 1)
                movel(pos[end])
                grip(-1)
                write(end,val)
                movel(up(pos[end]))                
            else:move(start,end,ispass,[0,5]) # 1 칸 이동
        
    if Type == 1: # is 'B'
        # 인덱스에서 팩 가져오기
        while index_li().count(0) < 6:
            pack = read(69,True)
            if pack <= 6:
                val = pack # 잡을 팩
                movel(trans(index_pos,[0,0,35,0,0,0]))
                movel(index_pos)
                grip(1)
                write(69,0,True)
                movel([0,0,80,0,0,0],mod = 1)
                it(1,0) # 인덱스 회전                
                goal_pos = [i+9 for i in range(9) if read(i) == pack][0] # 잡은 팩과 같은 팩의 위 좌표                
                move(None,goal_pos,False,[35,85])                
            else: it(1) # 인덱스 회전        
        # 정렬
        for i in range(len(Path)):
            start,end = Path[i]
            ispass = i+1 <  len(Path) and Path[i+1][0] == end
            if start - end not in [-3,3,-1,1]:
                move(start,None,True)
                move(None,(end if end < 9 else start) + 9,True)
                move(None,end,ispass)
            else: move(start,end,ispass,[35,5])

    if Type == 2: # is 'C'
        global angle
        angle = 1 # 그피퍼 각도
        gantry(-0.5 if gantry_pos > 0 else 0.5) # 검은선 원점 맞추기
        gantry_pos += 1.5 # A 에서는 원점이 앞검은선인데 C 에서는 중앙 검은 선임
        griper_pos = Path[0][0] # 그리퍼 위치
        
        # C 파레트 첫 진입
        movel(trans(pos[Path[0][0]],[0,0,35,0,0,0]))
        movel(pos[Path[0][0]])
        
        for i in range(len(Path)):
            start,end = Path[i]
            ispass = i+1 <  len(Path) and Path[i+1][0] == end
            
            # 인덱스 회전 
            pack = read(start) if read(start) else val
            goal_Dir = [0,4,6,2][(-4,4,-1,1).index(end - start)] # 목표 방향 
            Dir = index_li().index(7 if pack < 4 else 8) # 현재 방향 
            turn_ct = [(Dir+i)%8 for i in range(8)].index(goal_Dir) # 정회전시 필요한 회전수
            it(-(8-turn_ct) if turn_ct > 4 else turn_ct,0.35) # 인덱스 회전
            
            # 그리퍼 무빙            
            e = (start//4,start%4) # 그리퍼 도착위치 y,x            
            while griper_pos != start:
                s = [griper_pos//4,griper_pos%4]
                next_pos = [e[0]*4+s[1],s[0]*4+e[1]] # y좌표를 도착 좌표와 일치 시켰을때, x "
                next_pos = [i if griper_pos != i and read(i) not in [1,2,3] or i == start else None for i in next_pos] # 이동할 위치가 도착지거나 그리퍼를 돌릴 수 있는 위치인가
                if read(griper_pos) in [1,2,3]: next_pos[not(angle)] = None # 현재 그리퍼각도로 갈 수 없는 곳(그리퍼가 돌릴 수 없는 위치에 있을 때)                
                if next_pos.count(None) != 2: # 이동 가능한 방향이 있을때 
                    for i in range(2):
                        if next_pos[i] != None:
                            movel(turn(i,pos[griper_pos]))
                            movel(turn(i,pos[next_pos[i]]))
                            griper_pos = next_pos[i]
                            break
                else: # 없을때 
                    other_pos = [s[0]*4+i if angle else i*4+s[1] for i in range(4) if s[angle] != i]
                    other_pos = [i for i in other_pos if read(i) not in [1,2,3]]
                    if other_pos:
                        movel(turn(angle,pos[other_pos[0]]))
                        griper_pos = other_pos[0]
                    else: movel(turn(not(angle),pos[griper_pos]))
            
            #겐트리 무빙
            goal_gantry_pos = [read(i,True) for i in range(9,18)].index(pack)
            while goal_gantry_pos != gantry_pos:
                if gantry_pos < goal_gantry_pos: gantry(+1)
                else: gantry(-1)      
                
            move(start,end,ispass,[0,5])
            griper_pos = end
            
    movel([0,0,35,0,0,0],mod = 1)
    movej([90,0,90,0,90,0],90,90)
        
# M A I N
import time
grip(-1)
movej([90,0,90,0,90,0],75,75)

#__RUN__
start = time.time() # Start
#write(99,1,True)#buzz

Run(0)
Run(1)
Run(2)

#write(99,1,True)#buzz
end = time.time() # End

printf('--',round((end - start)/60,3),'분--') # time'''
