drl_report_line(OFF)
printf = lambda *n: tp_log(' '.join(list(map(str,n))))

w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 4'.split()
r = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 4'.split()
w[0],r[0] = [5] * 2
w[-1],r[-1] = [4] * 2

for i in [w,r]:
    i[1:-1] = list(map(lambda a: ord(a),i[1:-1]))
    
def write(ad, val,isabs = False):
    if not isabs: ad += (0 if Rn == 'A' else 40 if Rn == 'B' else 60) # 값, 디바이스 오차
    ser = serial_open(port = 'COM')
    w[13] = ord(str(ad//100))
    w[14] = ord(str((ad%100)//10))
    w[15] = ord(str(ad%10))
    w[18] = ord(str(0)) if val < 16 else ord(hex(val)[2])
    w[19] = ord(hex(val)[2]) if val < 16 else ord(hex(val)[3])
    ser.write(bytearray(w))
    serial_close(ser)
    wait(0.02)
    
def read(ad,isabs = False):
    if not isabs: ad += (0 if Rn == 'A' else 40 if Rn == 'B' else 60) # 값, 디바이스 오차
    ser = serial_open(port = 'COM')
    r[13] = ord(str(ad//100))
    r[14] = ord(str((ad%100)//10))
    r[15] = ord(str(ad%10))
    ser.write(bytearray(r))
    wait(0.02)
    n = int(ser.read(ser.inWaiting()).decode()[10:14],16)
    serial_close(ser)
    return n

from collections import deque

def chn(board: str, now: int , new: int ):
      br = list(board) # str -> list
      br[now],br[new] = br[new],'0'
      return ''.join(br) # list -> str

def Truedirs(board: str):
      result = []      
      n_p = (ct for ct,i in enumerate(board) if i == '0' and ct not in fix[1])
      def rule(board,pos,posN):
            if Type == 0:
                  if board[posN] in fix[0] or posN in fix[1]: return False
                  if board[posN] == 'h':
                        Dir = (-5,5,-1,1).index(posN - pos)
                        if posN not in wall[Dir] and board[posN + (posN - pos)] not in ['0','h']:
                              result.append(chn(board,pos,posN + (posN - pos)))
                        return False
                  return True
            if Type == 1:
                  dy,dx = [-1,1,0,0],[0,0,-1,1]
                  # '포'는 '포'가 아닌 다른 기물을 넘어서 이동한다.
                  if board[posN] not in ['p','0']:
                        def posa(y,x,mode):
                              for i in range(4):
                                    if [-5,5,-1,1][i] == state:
                                          y,x = y + dy[i], x + dx[i]
                                          break
                              if not 0 <= y <= 3 or not 0 <= x <= 4 or (not mode and board[y*5+x] in ['m','s','c','g']): return None
                              elif board[y*5+x] == ('0' if mode else 'p'):
                                    if mode: result.append(chn(board, y*5+x,init[0]*5+init[1]))
                                    else: return y*5+x
                              return posa(y,x,mode)
                        
                        Ny,Nx,state = posN // 5,posN % 5, posN - pos
                        p_pos = posa(Ny,Nx,0)
                        if p_pos is not None:
                              Ay,Ax,state = p_pos // 5, p_pos % 5, pos - posN
                              init = Ay,Ax
                              posa(Ny,Nx,1)
                              
                  # 바로 옆에 '포'가 있으면 False     
                  if board[posN] == 'p': return False # 바로 옆에 '포'가 있으면 False            
                  # '수'는 궁 주위 8칸 안에서만 이동
                  if board[posN] == 's' and pos not in g_li:return False
                  # '마'는 직진후 대각이동 ***직진과 대각이동을 한 노드에 넣음
                  if board[posN] == 'm':                        
                        posa,Dir = pos + (pos - posN),pos - posN
                        if pos in wall[[-5,5,-1,1].index(Dir)]: return False
                        y,x = posa // 5, posa % 5
                        for i in [range(2,4),range(2)][Dir in (-1,1)]:
                              ny,nx = y+dy[i],x+dx[i]
                              nz = ny * 5 + nx
                              if 0 <= ny <= 3 and 0 <= nx <= 4 and board[nz] == '0':
                                    result.append(chn(board,nz,posN))
                        return False                              
                  if board[posN] in fix[0] or posN in fix[1]: return False                  
                  return True # 기물에 따른 조건이 모두 성립하면 True                  
            if Type == 2:
                  if board[posN] in fix[0] or posN in fix[1]: return False
                  return True
      for pos in n_p:
            if fix[2][0] and pos not in wall[0] and rule(board, pos, pos - val):
                  result.append(chn(board,pos,pos-val)) # ↑  
            if fix[2][1] and pos not in wall[1] and rule(board, pos, pos + val):
                  result.append(chn(board,pos,pos+val))  # ↓ 
            if fix[2][2] and pos not in wall[2] and rule(board, pos, pos - 1):
                  result.append(chn(board,pos,pos - 1)) # ←  
            if fix[2][3] and pos not in wall[3] and rule(board, pos, pos + 1):
                  result.append(chn(board,pos,pos + 1)) # →
      return result

def bfs(root: str,leaf = None,idx = None,score:'Distance Score' = None):
      que = deque([root])
      marked = {root:'root'}
      br = root
      def isleaf(br):            
            if Type == 0:                 
                  if idx != None: # idx
                        if leaf[idx] == '0':
                              idx_li = [i for i in range(20) if br[i] == '0' and i not in fix[1]]
                              Nscore = Scoring(idx_li[0],idx)  
                        else:Nscore = Scoring(br.index(leaf[idx]),idx)
                        return not Nscore < score  # 처음 점수와 비교하여 작으면 False                
                  return br != leaf # all            
            if Type == 1:
                  li = [br[i] for i in g_li]
                  return li.count('0') != leaf # leaf = 목표로 하는 궁 주위의 빈 칸 갯수            
            if Type == 2:
                  if leaf == 'push': return br[idx] == '0'
                  if leaf == None:
                        if br[idx] not in C1_li: # solting
                              C1_li.add(br[idx])
                              return False
                        return True
                  if leaf != None: return br[idx] != leaf
      while isleaf(br):
            br = que.popleft()
            for child_br in Truedirs(br):
                  if child_br not in marked:
                        marked[child_br] = br
                        que.append(child_br)
      marked['leaf'] = br
      if idx != None and score == None: fix[1].add(idx)
      return marked

def path(marked):
      br = marked['leaf'] # 이전 탐색의 단말 노드
      path = [br]
      while marked[br] != 'root':
            br = marked[br]
            path.append(br)
      return path[::-1][1:]

def main(r:'root',l:'leaf',T: 'Types of Parets'):
      #Global Variables
      global root,leaf,Type,fix,wall,val,g_li # 고정,벽,오차
      root,leaf,Type = r,l,T
      fix = [[{'0'},{'0','g'},{'0',' '}][Type],set(),[1,1,1,1]]
      wall = (({0,1,2,3,4},{15,16,17,18,19},{0,5,10,15},{4,9,14,19}),
             ({0,1,2,3,4,5},{18,19,20,21,22,23},{0,6,12,18},{5,11,17,23}))[Type > 1]
      val = (5,5,6)[Type]
      if Type == 1: g_li = [root.index('g') + i for i in (-6,-5,-4,1,6,5,4,-1)]
      result = []
      start = time.time() # Start      
      if Type == 0:
            global Scoring # main,bfs
            def Scoring(start,end):
                  start,end = (start//5,start%5),(end//5,end%5)
                  score = abs(start[0]-end[0]) + abs(start[1]-end[1]) # Distance Score
                  return score
            Sequence = (0,19,5,14,10,9,15,4,1,2,3)# 정렬 순서
            marked = {'leaf':root}
            for idx in Sequence:
                  print(idx,leaf[idx])
                  if leaf[idx] == 'h':
                        fix[1].add(idx) # 수동 고정
                        continue
                  if leaf[idx] == '0':
                        idx_li = [i for i in range(20) if marked['leaf'][i] == '0' and i not in fix[1]]
                        score = Scoring(idx_li[0],idx)            
                  else: score = Scoring(marked['leaf'].index(leaf[idx]),idx)
                  for i in range(score,0,-1): # 현재 점수에서 1점까지                      
                        marked = bfs(marked['leaf'],leaf,idx,i)
                        result += path(marked)                        
                  fix[1].add(idx) # 수동 고정
            result += path(bfs(marked['leaf'],leaf)) # 3 x 3 정렬 
            
      if Type == 1:
            marked = {'leaf':root}
            c_pos = [i for i in range(20) if root[i] == 'c']            
            for i in c_pos:
                  if i not in g_li:
                        fix[1].add(i)
                        break                  
            li = [marked['leaf'][i] for i in g_li]
            for i in range(li.count('0'),0,-1):
                  print(i)
                  marked = bfs(marked['leaf'],i) # 궁 주변에 빈칸이 1개 일때   
                  result += path(marked)                  
            fix[1].clear() # 고정 없음
            result += path(bfs(marked['leaf'],0)) # 궁 주변에 빈칸이 없을때

      if Type == 2:
            global C1_li      
            def push(root,idx_li): # PUSH 7
                  marked,Path = {'leaf':root},[]
                  for i in idx_li:
                        marked = bfs(marked['leaf'],'push',i)
                        Path += path(marked)
                  fix[1] -= set(idx_li) # 밀었던 인덱스 고정 해제
                  return Path,marked  
            # P U S H I N G
            Path,marked = push(root,(4,5,22,23,11,17,16,10,15,9,14,8))
            result += Path                  
            # C1구역에 각각다른 팩을 배치
            C1_li,li = set(),(1,0,6,12,18,19,7,13)
            for i in li:
                  marked = bfs(marked['leaf'],None,i)
                  result += path(marked)      
            # P U S H I N G
            Path,marked = push(marked['leaf'],(8,9,14,15))
            result += Path
            # C2구역에 대칭 배치
            for i in li:
                  j = i + (3 if i % 2 else 5) # 대칭 인덱스
                  marked = bfs(marked['leaf'],marked['leaf'][i],j)
                  result += path(marked)

      # list -> index
      def converter(result):
            first,path = root,[]
            for second in result:
                  step = [None,None]
                  for i in range(len(second)):
                        if first[i] != second[i]:
                              if first[i] =='0': step[1] = i
                              else: step[0] = i
                  path.append(step)
                  first = second[:]
            return path
            
      # list -> index
      result = converter(result)
      return result
      
# M O V I N G
set_velx(2000); set_accx(1800); begin_blend(2.5) # Global

Positions = {'A':posx(462.19, 204.45, 27.7, 16.4, 180, -73.19),
'B':posx(-264.26, 204.06, 26.24, 167.54, -180, 77.76),
'C':posx(145.38, 360.31, 26.61, 70.2, -179.99, -19.53)}

isgrip = 0
def grip(n):
    global isgrip
    if isgrip == n: return -1
    mwait(0)
    set_tool_digital_outputs([1*n,2*-n])
    if n==1: wait(0.18)
    isgrip = (0 if n == -1 else 1)
    
def posing(pos):
    x_size =  5 if Rn in ['A','B'] else 6
    pos,n = [pos] * (x_size * 4),(50 if x_size == 5 else 57) 
    for i in range(1,int(x_size*4)):
        if i % x_size: pos[i] = trans(pos[i-1],[-n,0,0,0,0,0])
        else: pos[i] = trans(pos[i-x_size],[0,n,0,0,0,0])
    return pos

def input_br(a,b):
    p_name = [{10:'a',11:'b',12:'c',13:'d',14:'h'},{1:'m',2:'s',3:'c',4:'p',5:'g'}][Rn=='B']
    board = [read(i) for i in range(a,b)]
    if Rn != 'C':  br = [p_name[i] if i in p_name else str(i) for i in board]
    else:  br = [' ' if ct in [2,3,20,21] else str(i) for ct,i in enumerate(board)]
    return ''.join(br)

up_pos = lambda: ([0,0,0 if Rn == 'A' else 35,0,0,0],[0,0,35 if Rn == 'B' else 5,0,0,0])[isgrip] # 상대 값 
up = lambda pos: trans(pos,up_pos())

turn = lambda n,pos: [pos[0],pos[1],pos[2],[0,90][n],180,0] # pos 에서 회전한 좌표를 return 
# 현재 위치에서 회전
def turning(n):
    global angle
    if angle == n: return -1
    pos,angle = get_current_posx()[0],n
    if read(grip_p) in [7,8,9,10,11,12,13]: grip(1) # 회전할 때 사각팩
    mwait(0)
    movel([pos[0],pos[1],pos[2],[0,90][n],180,0],4000,4000)    
    grip(-1)

pass_stack,val = 0,0
def move(start,end,ispass = False):
    global pass_stack,val # 패스 스택, 통신값
    pos = posing(Positions[Rn]) # Positions
    downspeed = 1200 if Rn == 'B' else 800 # downspeed
    for ct,i in enumerate((start,end)):
        Pos = turn(angle,pos[i])        
        if not pass_stack: movel(up(Pos))        
        if ct and ispass: pass_stack += 2 # 현재 스텝 끝, 다음 스텝 시작 pass        
        if not pass_stack:
            movel(Pos,None,downspeed)
            grip(-1 if ct else 1)
            if not ct: val = read(i)
            write(i,val if ct else 0)
            movel(up(Pos),None,downspeed)
        else: pass_stack -= 1     
        
        if Rn=='A' and not isgrip: # 팩을 놨을때
            global grip_p
            grip_p = end
            if start - end in [-5,5,-10,10] and angle: turning(0)
            if start - end in [-1,1,-2,2] and not angle: turning(1)
            movel(up(turn(angle,pos[start])))
            grip_p = start
        
def Run(Type:str):
    global Rn,angle,grip_p
    Rn = Type # Running Now.
    root = input_br(0,24) if Type == 'C' else input_br(0,20)
    leaf = input_br(20,40) if Type == 'A' else None 
    # 일반,팩 잡았을때 상대 값 A: 2,2 B: 35,15 C: 35,2
    pos = posing(Positions[Type]) # Positions
    Path = main(root,leaf,['A','B','C'].index(Type)) # get
    
    grip_p,angle = [0,5,10,15][read(90)-1],1 # 그리퍼 위치, 각도
    if Type == 'A':
        
        #입구 진입
        gate_pos = [0,5,10,15][read(90)-1]
        gate = turn(1,pos[gate_pos])
        movel(trans(gate,[0,0,50,0,0,0]))
        movel(up(gate))
        
        def movegrip(end): # 그리퍼 이동
            global grip_p,angle       
            s,e = (grip_p//5,grip_p%5),(end//5,end%5) # y,x
            for i in range(2): # y,x
                if s[i] != e[i]:
                    turning(i) # 현재위치에서 i각도로 회전
                    goal_pos = end if i else  e[0]*5+s[1]
                    movel(turn(i,pos[goal_pos]))
                    grip_p = goal_pos # 그리퍼 위치
                
        for i in range(len(Path)):
            global grip_p,angle
            start,end = Path[i]
            ispass = i+1 <  len(Path) and Path[i+1][0] == end
            if not isgrip: movegrip(start)
            move(start,end,ispass) # 스텝
            
    if Type == 'B':
        # 마 사 차 포
        for i in range(len(Path)):
            start,end = Path[i]           
            pack = read(start)            
            if pack == 1: # 마
                dirs = [(-11,-9),(9, 11),(-7,3),(-3,7),-5,5,-1,1]
                dir = end - start
                for i in range(4):
                    if dir in dirs[i]:
                        move(start,start+dirs[4+i],True)
                        break
                move(start+dirs[4+i],end)
                wait(3) # 3초간 정지 ***
                
            elif pack == 4: # 포
                movel_t = lambda pos: movel(turn(angle,pos))                 
                def movep(p,n,val):
                    movel_t(up(pos[p]))
                    movel_t(pos[p])
                    grip(n)
                    write(p,val)
                    movel_t(up(pos[p]))                
                dir = 5 if end-start >= 5 else 1  if end-start > 0 else  -5 if end-start <= -5 else -1                
                if dir >= 5 or dir <= -5: path = [i for i in range(start,end,5 if dir > 0 else -5)][1:]
                else: path = [i for i in range(start,end,1 if dir > 0 else -1)][1:]

                movep(start,1,0)                
                for i in path:
                    pack = read(i)
                    if pack: 
                        movel([0,0,40,0,0,0], mod = 1)
                        movel_t(up(trans(pos[i],[0,0,40,0,0,0])))
                        movel_t(up(trans(pos[i+dir],[0,0,40,0,0,0])))
                    else: movel_t(up(pos[i])) 
                movep(end,-1,4)
                wait(3) # 3초간 정지 ***
            else:
                ispass = i+1 <  len(Path) and Path[i+1][0] == end
                move(start,end,ispass) # 스텝
                if not ispass: wait(3) # 3초간 정지 ***
        
    if Type == 'C':
        for i in range(len(Path)):
            start,end = Path[i]
            ispass = i+1 <  len(Path) and Path[i+1][0] == end       
            move(start,end,ispass) # 스텝
            
    movel([0,0,40,0,0,0],mod = 1)
    movej([90,0,90,0,90,0],65,65)
 
# M A I N
import time
grip(-1)
movej([90,0,90,0,90,0],65,65)
#sub_program_run('hmi') # HMI reset

#__RUN__
start = time.time() # Start
#write(99,1,True)#buzz
printf('\n')
#Run('B')
#Run('C')
Run('A')
end = time.time() # End
#write(99,1,True)#buzz
printf('--',round((end - start)/60,3),'분--') # time'''
