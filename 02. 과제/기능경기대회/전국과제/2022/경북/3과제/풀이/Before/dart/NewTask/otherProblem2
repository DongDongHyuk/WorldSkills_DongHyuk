drl_report_line(OFF)
printf = lambda *n: tp_log(' '.join(list(map(str,n))))

w = '5 0 0 W S S 0 1 0 6 % D W 0 0 0 0 0 0 0 4'.split()
r = '5 0 0 R S S 0 1 0 6 % D W 0 0 0 4'.split()
w[0],r[0] = [5] * 2
w[-1],r[-1] = [4] * 2

for i in [w,r]:
    i[1:-1] = list(map(lambda a: ord(a),i[1:-1]))
    
def write(ad, val, isabs: '절대적 주소' = False):
    if not isabs: ad += ([0,16][A1orA2] if Rn == 0 else 64 if Rn == 1 else 73) # 값, 디바이스 오차
    ser = serial_open(port = 'COM')
    w[13] = ord(str(ad//100))
    w[14] = ord(str((ad%100)//10))
    w[15] = ord(str(ad%10))
    w[18] = ord(str(0)) if val < 16 else ord(hex(val)[2])
    w[19] = ord(hex(val)[2]) if val < 16 else ord(hex(val)[3])
    ser.write(bytearray(w))
    serial_close(ser)
    wait(0.02)
    
def read(ad,isabs = False):
    if not isabs: ad += ([0,16][A1orA2] if Rn == 0 else 64 if Rn == 1 else 73) # 값, 디바이스 오차
    ser = serial_open(port = 'COM')
    r[13] = ord(str(ad//100))
    r[14] = ord(str((ad%100)//10))
    r[15] = ord(str(ad%10))
    ser.write(bytearray(r))
    wait(0.02)
    n = int(ser.read(ser.inWaiting()).decode()[10:14],16)
    serial_close(ser)
    return n

from collections import deque

def chn(board: str, now: int , new: int ):
      br = list(board) # str -> list
      if Type == 1: #is 'B' board
            now_pack = br[new] # 옮기는 팩
            mate_pack = now_pack.lower() if now_pack.isupper() else now_pack.upper() # 옮기는 팩의 메이트
            br[br.index(mate_pack)] = '0'
      if Type == 2:
            if br[new] == 'b': # isBridge
                  new = new + (new - now)
      br[now],br[new] = br[new],mate_pack if Type == 1 else '0'
      return ''.join(br) # list -> str

def Truedirs(board: str):
      result = []
      n_p = [ct for ct,i in enumerate(board) if i == '0' and ct not in fix[1]]
      def rule(board,pos,posN):
            if Type == 0:
                  if board[posN] == 'p': # isPortal
                        posN = posN + (posN - pos)
                        if board[posN] not in fix[0]:
                              result.append(chn(board,pos,posN))
                        return False            
            return posN not in fix[1] and board[posN] not in fix[0]
      for pos in n_p:
            if pos not in wall[0] and rule(board, pos, pos - val):
                  result.append(chn(board,pos,pos-val)) # ↑  
            if pos not in wall[1] and rule(board, pos, pos + val):
                  result.append(chn(board,pos,pos+val))  # ↓ 
            if pos not in wall[2] and rule(board, pos, pos - 1):
                  result.append(chn(board,pos,pos - 1)) # ←  
            if pos not in wall[3] and rule(board, pos, pos + 1):
                  result.append(chn(board,pos,pos + 1)) # →
      return result
      
def bfs(root: str,leaf=None,idx=None,A_type=None,score:'Distance Score' = None):
      que = deque([root])
      marked = {root:'root'}
      br = root
      def isleaf(br):
            if Type == 0: # 'A'
                  if leaf == 'porting':
                        return idx not in p_around_pack(br,A_type)
                  if idx is not None:
                        if score is not None:
                              Nscore = Scoring(br.index(leaf[idx]),idx)
                              return not Nscore < score
                        return br[idx] != leaf[idx]
                  return br != leaf
            if Type == 1: # 'B'
                  pack_pos_li = lambda br:[br.index(i) for i in ['A','B','C','a','b','c']] # B
                  A,B,C,a,b,c = map(int,pack_pos_li(br))
                  if 4 not in {B,b}: return True # B or b not in center_B 또는 b가 정중앙에 있어야됨
                  if not((A - B) in [1,-1,3,-3] and (A - B) == (B - C)): return True
                  if not((a - b) in [1,-1,3,-3] and (a - b) == (b - c)): return True
                  return False
            if Type == 2: # 'C'
                  pack_li = lambda br:({br[i]for i in range(10)},{br[j]for j in range(10,15)})
                  a,b = pack_li(br)
                  return not('2' not in a and '1' not in b)
      while isleaf(br):
            br = que.popleft()
            for child_br in Truedirs(br):
                  if child_br not in marked:
                        marked[child_br] = br
                        que.append(child_br)
      marked['leaf'] = br
      return marked

def path(marked):
      br = marked['leaf'] # 이전 탐색의 단말 노드
      path = [br]
      while marked[br] != 'root':
            br = marked[br]
            path.append(br)
      return path[::-1]

def main(r:'root',l:'leaf',T: 'Types of Parets'):
      #Global Variables
      global root,leaf,Type,fix,wall,val # 고정,벽,오차
      root,leaf,Type = r,l,T
      fix = ({'x'},set()) # 고정 팩,고정 인덱스
      wall = [({0,1,2,3},{12,13,14,15},{0,4,8,12},{3,7,11,15}),
              ({0,1,2},{6,7,8},{0,3,6},{2,5,8}),
              ({0,1,2,3,4},{10,11,12,13,14},{0,5,10},{4,9,14})][T]
      val = [4,3,5][T]   
      result = []
      
      if T == 0: # A
            global p_pos,p_around,p_around_pack,Scoring
            p_pos = (root[0].index('p'),root[1].index('p')) # 포탈 위치          
            p_around = [[p_pos[0] + i for i in [-4,4,-1,1] if 0 <= p_pos[0] + i < 16]] # 포탈 위치 주변
            p_around.append([p_pos[1] + i for i in [-4,4,-1,1] if 0 <= p_pos[1] + i < 16])
            p_around_pack = lambda br,n: [br[i] for i in p_around[n]] # 포탈 주변 팩들(sync)
            pack_li = [[i for i in root[0] if i not in ['x','p','0']]] # A1,A2 팩
            pack_li.append([i for i in root[1] if i not in ['x','p','0']])
            def Scoring(start,end):
                  start,end = (start//4,start%4),(end//4,end%4)
                  score = abs(start[0]-end[0]) + abs(start[1]-end[1]) # Distance Score
                  return score
            result,result0,result1 = [[],[],[]],[],[]
            
            # 서로의 팩을 교환 해야됨
            marked0,marked1 = {'leaf':root[0]},{'leaf':root[1]}            
            def porting(n1:'del',n2:'add',num): # 보드에 팩 지우기
                  board1,board2 = [marked0['leaf'],marked1['leaf']][n1],[marked0['leaf'],marked1['leaf']][n2]
                  board1,board2 = list(board1),list(board2)
                  board1[board1.index(num)] = '0' # del
                  pos = p_around[n2][p_around_pack(board2,n2).index('0')]
                  board2[pos] = num # add
                  if n1: return ''.join(board2),''.join(board1)
                  return ''.join(board1),''.join(board2)
            
            marked0 = bfs(marked0['leaf'],'porting','0',0)
            result[0] = path(marked0)  # A1_board_setting            
            for i,j in zip(pack_li[0],pack_li[1]): # porting
                  # A2 --> A1
                  marked1 = bfs(marked1['leaf'],'porting',j,1)
                  result1 += path(marked1)
                  marked0['leaf'],marked1['leaf'] = porting(1,0,j)                  
                  # A1 --> A2
                  marked0 = bfs(marked0['leaf'],'porting',i,0)
                  result0 += path(marked0)
                  marked0['leaf'],marked1['leaf'] = porting(0,1,i)                  
                  result[1].append([result1,result0]) # 팩을 서로 한개씩 교환한 상태에서 append
                  result0,result1 = [],[] # reset

            for marked,Result,leaf in zip([marked0,marked1],[result0,result1],[leaf[0],leaf[1]]):
                  center = [i for i in [5,6,9,10] if marked['leaf'][i] not in ['p','x']][0]
                  sequence = [i for i in range(16) if i not in list(map(lambda n:center+n,[-5,-4,-3,1,5,4,3,-1]))+[center]]
                  for idx in sequence:
                        if leaf[idx] == '0': # 0 은 거리 점수X
                              marked = bfs(marked['leaf'],leaf,idx)
                              Result += path(marked)
                        else: # 0 을 제외한 팩은 거리 점수 O
                              score = Scoring(marked['leaf'].index(leaf[idx]),idx)
                              for i in range(score,0,-1):
                                    marked = bfs(marked['leaf'],leaf,idx,None,i)
                                    Result += path(marked)
                        fix[1].add(idx)
                  marked = bfs(marked['leaf'],leaf)
                  Result += path(marked)[1:]
                  result[2].append(Result)
                  fix[1].clear()
                              
      else: # B,C
            result += path(bfs(root,leaf)) # B,C

      # list -> index
      def converter(result):
            if not len(result): return []
            first,path = result[0],[]
            for second in result[1:]:
                  step = [None,None]
                  for i in range(len(second)):
                        if first[i] != second[i]:
                              if first[i] =='0': step[1] = i
                              else: step[0] = i
                  if None not in step: path.append(step)
                  first = second[:]
            return path
      
      def converter_1(result): # B 파레트 전용
            if not len(result): return []
            first,path = result[0],[]
            for second in result[1:]:
                  step = [None] * 4
                  for i in ['a','b','c']:
                        if first.index(i) != second.index(i):                              
                              step[0],step[1] = first.index(i),second.index(i)
                              pack_state = first.index(i.upper()) - step[0]
                              step[3] = second.index(i.upper()) - step[1]                              
                              if pack_state in [1,-1]: # 팩이 가로
                                    l,r = (-3,3) if pack_state == 1 else (3,-3)
                              else: l,r = (1,-1) if pack_state == 3 else (-1,1) # 세로                              
                              n1,n2 = first.index(i.upper()),first.index(i)
                              turn_dir = [n1+l,n1+r,n2+l,n2+r]                              
                              for j in range(4):
                                    if not(0 <= turn_dir[j] < 9):continue
                                    if second[turn_dir[j]] in [i,i.upper()]: step[2] = j                              
                  path.append(step)
                  first = second[:]
            return path
      
      if T == 0: # A result = [[A1_setting],[ [[[]*n],[[]*n]], * 9 ]
            setting_result = converter(result[0]) # setting
            porting_result = [] # porting
            for result1 in result[1]:
                  result2 = []
                  for result3 in result1:
                        result2.append(converter(result3))
                  porting_result.append(result2)
            solting_result = [] # solting
            for i in result[2]:
                  solting_result.append(converter(i))
            print([setting_result,porting_result,solting_result])
            return [setting_result,porting_result,solting_result]
      
      if T == 1: # B
            result = converter_1(result)
            print(result)
            return result
      
      if T == 2: # C
            result = converter(result)
            print(result)
            return result
            
# M O V I N G
set_velx(2400); set_accx(1800); begin_blend(2.5) # Global

Positions = {0:(posx(150.23, 358.79, 187.71, 66.36, -180, -23.64),posx(-29.64, 359.79, 187.7, 152.24, -179.99, 62.24)),
                   1:posx(340.68, 298.29, 162.9, 155.15, -179.99, 65.15),
                   2:posx(-261.15, 222.74, 183.86, 11.62, -180, -78.38)}

isgrip = 0
def grip(n):
    global isgrip
    if isgrip == n: return -1
    mwait(0)
    set_tool_digital_outputs([1*n,2*-n])
    if n==1: wait(0.18)
    isgrip = (0 if n == -1 else 1)
    
def posing(pos):
    x = [4,3,5][Rn]
    pos,n = [pos] * [16,9,15][Rn],40     
    for i in range(1,[16,9,15][Rn]):
        if i % x: pos[i] = trans(pos[i-1],[-n,0,0,0,0,0])
        else: pos[i] = trans(pos[i-x],[0,n+(20 if Rn == 2 else 0),0,0,0,0])
    return pos
    
p_name = {11:'a',12:'b',13:'c',14:'d',15:'e',16:'f',17:'g',18:'h',19:'i',21:'x',22:'p'}
def input_br(a,b):
    br = [read(i) for i in range(a,b)]
    if Rn == 0: #A
        br = [p_name[i] if i in p_name else i for i in br]
    if Rn == 1: # B
        for i in range(9):
            if type(br[i]) == int and br[i] != 0:
                pack = ('a' if br[i] < 20 else 'b' if br[i] < 30 else 'c')
                dir = int(str(br[i])[1])
                br[i],br[i+[-3,3,-1,1][[1,3,4,2].index(dir)]] = pack,pack.upper()
    if Rn == 2: # C
        for i in range(5,10):
            br[i] = 'x' if br[i] == 0 else 'b'            
    br = [str(i) for i in br]
    return ''.join(br)
   
up_value =  [[0,0,35,0,0,0],[0,0,5,0,0,0]]
up_pos = lambda: up_value[isgrip]
up = lambda pos: trans(pos,up_pos())
downspeed = 1300 # downspeed

pass_stack,val = 0,0
def move(start,end,ispass = False):
    global pass_stack,val,up_value # 패스 스택, 통신값, 그리퍼 상대 좌표
    for ct,i in enumerate((start,end)):        
        if i == None: continue
        if Rn == 0: # A 
            up_value =  [[0,0,35,0,0,0],[0,0,5,0,0,0]]
            Pos = [pos1[i],pos2[i]][A1orA2]
        else: Pos = pos[i] # B,C 
        if Rn == 2: # C 파레트에 다리 건널때 20 만큼 위로 더 들어야됨
            if start - end in [10,-10]: up_value =  [[0,0,35,0,0,0],[0,0,25,0,0,0]]
            else: up_value =  [[0,0,35,0,0,0],[0,0,5,0,0,0]]
        movel(up(Pos))
        if ct and ispass: pass_stack += 2 # 현재 스텝 끝, 다음 스텝 시작 pass        
        if not pass_stack:
            movel(Pos,None,downspeed)
            grip(-1 if ct else 1)
            if not ct: val = read(i)
            write(i,val if ct else 0)
            movel(up(Pos),None,downspeed)
        else: pass_stack -= 1
        
def Run(Type:int):
    global Rn,A1orA2,pos,pos1,pos2
    Rn = Type # Running Now.
    A1orA2 = 0 # defult
    root = (input_br(0,16),input_br(16,32)) if Type == 0 else input_br(0,9) if Type == 1 else  input_br(0,15)
    leaf = (input_br(32,48),input_br(48,64)) if Type == 0 else None    
    if Rn == 0: pos1,pos2 = posing(Positions[Type][0]),posing(Positions[Type][1])
    else: pos = posing(Positions[Type])    
    Path = main(root,leaf,Type)
    
    if Type == 0:
        porting_li = list(map(lambda li:[i for i in li if i not in ['0','x','p']],root[:])) # porting sequence 
        p_pos = [i if i < 16 else i -16 for i in range(32) if read(i) == 22]
        p_around = [[p_pos[0] + i for i in [-4,4,-1,1] if 0 <= p_pos[0] + i < 16]] # 포탈 위치 주변
        p_around.append([p_pos[1] + i for i in [-4,4,-1,1] if 0 <= p_pos[1] + i < 16])
        p_out_pos = lambda n: [i for i in p_around[n] if read(i+(16 if n else 0),True) == 0][0] # 현재 
        
        path,A1orA2 = Path[0],0 # A1 setting
        for i in range(len(path)):
            start,end = path[i]
            ispass = i+1 <  len(path) and path[i+1][0] == end
            move(start,end,ispass)
        path = Path[1] # porting
        for i in range(9):
            for ct,path_A in enumerate(path[i]): # 한 턴에 서로 팩 한개 교환
                for j in range(len(path_A)):
                    # ct  0 : A2, 1: A1
                    A1orA2 = not(ct)                    
                    start,end = path_A[j]
                    ispass = (j+1 <  len(path_A) and path_A[j+1][0] == end) or j+1 == len(path_A)
                    move(start,end,ispass)                    
                # 포탈
                if not isgrip: # 포탈 주변에 이미 팩이있으면 팩 잡는 모션 필요함
                    now_pack = porting_li[not(ct)][i]
                    for i in [-4,-1,1,4]:
                        n = read(p_pos[not(ct)] + i)
                        n = p_name[n] if n in p_name else str(n)
                        if n == now_pack:
                            move(p_pos[not(ct)]+i,p_pos[not(ct)],True)
                            break                            
                Pos = [pos1,pos2][not(ct)]
                movel(up(Pos[p_pos[not(ct)]]))
                movel([0,0,70,0,0,0], mod = 1)
                Pos = [pos1,pos2][ct]
                movel(trans(up(Pos[p_pos[ct]]),[0,0,70,0,0,0]))
                A1orA2 = ct
                move(p_pos[ct],p_out_pos(ct))
        
        path = Path[2]# solting
        for i in range(2):
            path_A,A1orA2 = path[i],i # solting
            for j in range(len(path_A)):
                start,end = path_A[j]
                ispass = j+1 <  len(path_A) and path_A[j+1][0] == end
                move(start,end,ispass)
                
    if Type == 1:
        angle = 0
        turn = lambda n,pos: [pos[0],pos[1],pos[2],[0,90][n],180,0]
        for i in range(len(Path)):
            start,end,n,end_state = Path[i]
            pack_angle = str(read(start))[1] in ['2','4']# 잡을 팩의 각도            
            for ct,i in enumerate([start,end]):                
                Pos = turn(pack_angle,pos[i])                
                if ct and n != None: 
                    amovel(up(Pos),200,200)
                    movel([0,0,0,90 if n in [0,3] else -90,0,0],mod = 1) # 그리퍼 돌리기
                    angle += (1 if n in [0,3] else -1)
                else: 
                    movel(up(Pos))
                    mwait(0)
                set_accx(1200) # 가속도
                movel([0,0,-5,0,0,0],mod = 1) if ct else movel(Pos) 
                grip(-1 if ct else 1)
                if not ct: 
                    pack = read(i)
                    val = (10 if pack < 20 else 20 if pack < 30 else 30) + [1,3,4,2][[-3,3,-1,1].index(end_state)]
                write(i,val if ct else 0)
                movel([0,0,35,0,0,0],mod = 1) if ct else movel(up(Pos))
                set_accx(2000) # 가속도                
            movel([0,0,0,90 if angle == -1 else -90,0,0],mod = 1)
            angle = 0
            
    if Type == 2:
        for i in range(len(Path)):
            start,end = Path[i]
            ispass = i+1 <  len(Path) and Path[i+1][0] == end
            move(start,end,ispass)
            
    movel(posx(-6.25, 436.01, 319.69, 90, 180, 0)) # 다른 파레트 이동시 경유지
    
# M A I N
import time
grip(-1)
movej([90,0,90,0,90,0],65,65)
sub_program_run('hmi').Hmi_write((0,88)) # HMI reset

#__RUN__
start = time.time() # Start

write(99,1,True)#buzz
Run(1) # B
Run(2) # C
Run(0) # A
write(99,1,True)#buzz

end = time.time() # End
printf('--',round((end - start)/60,3),'분--') # time'''
