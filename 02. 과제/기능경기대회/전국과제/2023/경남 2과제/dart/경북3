def exc(m,s,e,li=-1):
    m = list(m)
    m[s],m[e] = m[e],m[s]
    step = [e,s] if li == -1 else li
    return [''.join(m),[step,int(m[s])]]
def aro(pos):
    if pos in cache:
        return cache[pos]
    res = []
    if t:
        dy,dx = [-1,0,1,0],[0,1,0,-1]
    else:
        dy = [-1]*15+[0,0]+[1]*15+[0,0]
        dx = list(range(-7,8))+[1,7]+list(range(-7,8))+[-1,-7]
    y,x = divmod(pos,sx)
    for i in range(len(dy)):
        ny,nx = y + dy[i],x + dx[i]
        if -1 < ny < sy and -1 < nx < sx:
            res.append(ny * sx + nx)
    cache[pos] = res
    return res
def exp(n,m,pos=-1,pack=-1):
    res = []
    for i in range(size) if n > 0 else [pos]:       
        if (n > 0 and m[i] != '0') or i in fix:
            continue
        if t == 2 and n > 0 and i in hli:        # 홀 위에는 팩을 둘 수 없음
            continue        
        for j in aro(i):
            b1 = lambda i: m[i] in (['0x','x'][t == 2] if n > 0 else 'x') or i in fix
            b2 = lambda i,j: n == 2 and i == pos and m[j] != '0' and m[j] != pack
            if b1(j) or b2(i,j):
                continue
            if t == 0:
               if (abs(i-j) == 7 and i < 8) or \
                   (j < 8 and i not in [8,15]) or (i < 8 and j not in [8,15]):
                    continue
            if t == 2 and n > 0:
                if j in hli:
                    que = deque([j])
                    mkd = {j:i,i:-1}
                    while que:
                        cur = que.popleft()
                        for k in aro(cur):
                            if k != i and k not in mkd:
                                mkd[k] = cur
                                if k in hli:
                                    que.append(k)
                                if m[k] != '0':
                                    if b1(k) or b2(i,k):
                                        continue
                                    res1 = path(mkd,mkd,k)+[k]
                                    res.append(exc(m,i,k,res1[::-1]))
                if m[j] == '0':         # 0 끼리 교체 컨티뉴(홀 처리 이후)
                    continue
            res.append(exc(m,i,j) if n > 0 else [j,j])
    return res
def bfs(n,m,*a):
    global res    
    if n == -1:
        leaf,s,li = a 
    if n == 0:
        s,e = a
    if n == 1:
        leaf,pos,pack = a
    if n in [2,3]:
        pos,pack = a
    if n == 4:
        leaf,li1,li2 = a        
    cur = m if n > 0 else s
    que = deque([cur])
    mkd,step = {cur:-1},{cur:-1}
    while 1:
        cur = que.popleft()
        if n == -1 and leaf[cur] != '0' and cur not in li:
            break
        if n == 0 and cur == e:
            break
        if n in [1,2]:
            if (pos == -1 and cur == leaf) or (pos != -1 and cur[pos] == pack):
                break
        if n == 3 and cur[pos] not in ['0',pack]:
            break
        if n == 4 and [cur[i] for i in li1] == li2:
            break
        for i,j in exp(n,cur if n > 0 else m,
                       cur if n < 1 else pos if n == 2 else -1,
                       pack if n == 2 else -1):
            if i not in mkd:
                que.append(i)
                mkd[i],step[i] = cur,j                
    res1 = path(mkd,step,cur)    
    if n > 0 :
        res += res1
        return cur
    return res1
def path(mkd,step,cur):
    path = [step[cur]]
    while mkd[cur] != -1:
        cur = mkd[cur]
        path.append(step[cur])
    return path[::-1][1:]
def sort(m,leaf,e,p=-1):
    pack = leaf[e] if p == -1 else p
    res = []
    s = m.index(pack)
    r = bfs(0,m,s,e)
    if t == 2:
        r = [i for i in r if i not in hli]        
    for i in r:
        m = bfs(1,m,leaf,i,pack)
    fix.append(e)
    return m
def main(g_t,m,*a):    
    global t,sy,sx,size,fix,res,cache
    t = g_t
    sy,sx = [[2,8],[5,5],[4,4]][t]
    size = sy * sx
    fix = []
    res = []
    cache = {}      # cache reset
    if t == 0:
        leaf, = a
        for i in range(2):
            m = sort(m,leaf,[0,2][i],leaf[8+i])
        for i in [11,12]:
            m = bfs(1,m,leaf,i,'0')
            fix.append(i)
        fix = fix[:-2]        
        for i in range(4):
            m = sort(m,leaf,11-i,leaf[15-i])
        for i in range(4):
            m = bfs(1,m,leaf,12+i,'0')
            fix.append(12+i)
        for i in range(2):
            fix = [] if i else [0,2,5,7]
            for j in range(4):
                m = sort(m,leaf,[15,11][i]-j)
    if t == 1:
        leaf, = a
        li = [2,10,14,22]
        di = {2:7,10:11,14:13,22:17}
        hold = {}
        for i in range(2):
            fix = [hold[j] for j in hold]
            pos = [j for j in li if j not in fix and m[j] != 'x'][0]
            pack = leaf[di[pos]]
            for j in li:
                if j != pos and j not in fix:
                    m = bfs(3,m,j,pack)
                    fix.append(j)
            m = bfs(2,m,pos,pack)
            hold[di[pos]] = pos
            fix = [hold[j] for j in hold]            
        inli = [7,8,13,18,17,16,11,6]
        pos1 = [i for i in li if i not in fix and m[i] != 'x'][0]
        pos = [i for i,j in exp(0,m,pos1) if i in inli][0]
        pos3,pos2 = [inli[(inli.index(pos)-i)%8] for i in range(2)]
        m = bfs(1,m,leaf,pos1,'0')
        leafli = [leaf[i] for i in inli if i not in hold and leaf[i] != '0']
        n = leafli.index(m[pos3])
        leafli = [leafli[(n + i) % 6] for i in range(6)]    
        for pack in leafli:
            curli = [m[i] for i in inli if m[i] in leafli]            
            n = leafli.index(pack)-1
            bpack = leafli[n % len(curli)]                
            n = curli.index(pack)-1                
            if curli[n % len(curli)] == bpack:
                continue
            m = bfs(2,m,pos1,pack)
            for i in range(2):
                edit = fix.remove if i else fix.append
                edit(pos1)
                m = bfs(1,m,leaf,[pos2,pos3][i],[bpack,pack][i])
                edit(pos2)  
        fix = li[:]        
        for i in inli[::-1]:
            if i not in hold and leaf[i] != '0':
                m = bfs(1,m,leaf,i,leaf[i])
                fix.append(i)
        fix = []
        m = bfs(1,m,leaf,-1,-1)
    if t == 2:
        global hli
        leaf,hli = a        
        hold = {}       # 정렬 위치에 팩이 없을때 가까운 팩을 가져와서 홀딩
        xli = [i for i in range(16) if m[i] == 'x']         # 고정팩 위치
        pos = [i for i in [5,6,9,10] if i in xli]           # 중앙에 있는 고정팩
        vt = {5:15,6:12,9:3,10:0}       # 꼭짓점 위치
        if pos:
            pos = pos[0]        # 중앙 고정팩 위치                    
            outli = {5:[3,12,7,13,15,14,11], 6:[0,15,4,14,12,13,8], 9:[0,15,1,11,3,2,7], 10:[3,12,2,8,0,1,4]}[pos]       # 윤곽 정렬 위치
            inli = {5:[1,2,6,10,9,8,4,0], 6:[2,3,7,11,10,9,5,1], 9:[5,6,10,14,13,12,8,4], 10:[6,7,11,15,14,13,9,5]}[pos]         # 회전 초밥 위치
            b = lambda n:n not in hli and n !=vt[pos] and m[n] != 'x'       # 홀 x, 꼭짓점x, 고정 팩x
            pos1 = [i for i in outli if leaf[i] == '0' and b(i)]
            pos1 = pos1[0] if pos1 else [i for i in outli if b(i)][0]
            for i in outli:
                if i not in hli and i != pos1 and m[i] !='x':
                    if leaf[i] == '0' or i in hold:
                        pos2 = bfs(-1,m,leaf,i,hold)[-1]
                        m = sort(m,leaf,i,leaf[pos2])
                        hold[pos2] = i
                    else:
                        m = sort(m,leaf,i)
            m = bfs(1,m,leaf,pos1,'0')
            leafli = [leaf[i] for i in inli if i not in hold and leaf[i] != '0']
            for pack in leafli:
                curli = [m[i] for i in inli if m[i] in leafli]
                n = leafli.index(pack)-1
                bpack = leafli[n % len(curli)]                
                n = curli.index(pack)-1                
                if curli[n % len(curli)] == bpack:
                    continue                
                m = bfs(2,m,pos1,pack)      # 교체 할 팩 홀에 넣기
                pos = [i for i,j in exp(0,m,pos1) if i in inli][0]
                n = inli.index(pos)
                res1 = []
                for i in range(2):
                    li = [inli[(n + [-j,j][i]) % 8] for j in range(8)]
                    res1.append([j for j in li[1-i:] if j not in hli][0])                    
                pos2,pos3 = res1
                for i in range(2):
                    edit = fix.remove if i else fix.append
                    edit(pos1)
                    m = bfs(1,m,leaf,[pos2,pos3][i],[bpack,pack][i])
                    edit(pos2)                    
            if pos1 in hold:
                fix.remove(hold[pos1])
            m = bfs(2,m,pos1,leaf[pos1])
            fix.append(pos1)
            if pos1 in hold:
                fix.append(hold[pos1])                
            for i in inli:
                if i not in hold and leaf[i] != '0':
                    m = bfs(1,m,leaf,i,leaf[i])
                    fix.append(i)
            fix = []
            m = bfs(1,m,leaf,-1,-1)            
        else:
            unhold = []
            li = [0,3,12,15,1,2,13,14,4,8]      # overall sorting sequnce
            for i in [[0,1,4,3,7,12,13],[3,2,7,0,4,15,14],
                      [12,13,8,0,1,15,11],[15,14,11,3,2,12,13]]:       # not include fix pack "
                if 'x' not in [leaf[j] for j in i[:3]]:
                    li0 = i
            ct = 0
            for i in li0:
                if i not in hli and m[i] != 'x' and ct < 4:
                    if leaf[i] == '0' or i in hold:
                        pos = bfs(-1,m,leaf,i,hold)[-1]
                        m = sort(m,leaf,i,leaf[pos])
                        hold[pos] = i
                        unhold.append(pos)
                    else:
                        m = sort(m,leaf,i)
                    ct += 1            
            li1 = [i for i in range(16) if i not in fix and i not in hold]
            li2 = [leaf[i] for i in li1]        # leaf list            
            m = bfs(4,m,leaf,li1,li2)       # 홀딩 중인거 빼고 정렬
            for i in unhold[::-1]:
                fix.remove(hold[i])
                m = bfs(1,m,leaf,i,leaf[i])
                fix.append(i)            
    return res
    
tl = lambda *n:tp_log(' '.join(map(str,n)))
from collections import deque
drl_report_line(OFF)
set_tool('tool wei')
set_velx(1000); set_accx(2000)
set_velj([100,150,180,225,225,225]); set_accj(400)
begin_blend(10)
ml,mj,aml,amj,tr,wt = movel,movej,amovel,amovej,trans,wait
def mjx(pos,sol=-1):
    movejx(pos,sol = sol if sol != -1 else (3 if T == 2 else 2))
def rml(x=0,y=0,z=0,a=0,b=0,c=0,t=0.1,vel=None,acc=None):
    aml([x,y,z,a,b,c],mod=1,v=vel,a=acc)
    mwait(0) if t == -1 else wait(t)
def rmj(x=0,y=0,z=0,a=0,b=0,c=0,t=0.1,acc=None):
    amj([x,y,z,a,b,c],mod=1,a=acc)
    mwait(0) if t == -1 else wait(t)
def up(p,mod=0,h=-1):
    p,h = p[:],h if h != -1 else [260,260,260][T]
    p[2] = p[2] + h if mod else h
    return p
tool = 0
def cht(t=0.6,n = -1):
    global tool,pos
    if n != -1 and n == tool:
        return -1
    tool = (1 - tool)
    li = [180,-180] if T == 2 else [-180,180]
    rmj(c=li[0] if tool else li[1],t=t,acc=1500)
    pos = poss[tool][T]
isgrip = False
def grip(n):
    global isgrip
    isgrip = n
    if tool:
        if not n:
            wt(0.1)
        write(40,n,b=False)
        wt(0.15)
    else:
        set_tool_digital_outputs([1,-2] if n else [-1,2])
        wt(0.25)
def it(n,t=0.25):
    write(10,n,b=False)
    wt(t * abs(n))
    return 0.25 * abs(n)
gp = 4.5
def gt(n,t=0.12):
    global gp
    if n == gp:
        return -1
    write(20,n,b=False)
    n1 = 0.12 * abs(gp - n)
    wt(n1)
    gp = n
    return n1
        
ser=serial_open("COM")
def ts(ad,m=[],y=0,x=0,b=True):
    if b:
        ad += 100 * (1 + T)
    k='00'+['W','R'][bool(y)]+'SB06%DW'
    k=[ord(i) for i in k]
    n=len(m) if not y else y*x
    ad = [0]*(3-len(str(ad))) + list(map(int,str(ad)))
    k+=[ord(str(abs(i))) for i in ad]
    k+=[ord(i) for i in '{:02X}'.format(n)]
    if not y:
        for i in m:
            if i<0:
                i+=2**16
            k+=[ord(j) for j in '{:04X}'.format(i)]
    ser.write([5]+k+[4])
    wait(0.02 if n == 1 else 0.05)
    k=ser.read(ser.inWaiting())
    if y:
        for i in range(0,y*x*4,4):
            v=int(k[10+i:14+i],16)
            if v&(1<<15):
                v-=2**16 
            m.append(v)
        return m if len(m) > 1 else m[0]
def write(*a,b = True):
    if isinstance(a[0],int):
        a = [a]
    for i,j in a:
        ts(i,j if isinstance(j,list) else [j],b=b)
def read(ad,y=1,x=1,b=True):
    return ts(ad,[],y,x,b)

def writing_init_temp(): 
    global T
    li1 = [[6,0,3,0,0,8,0,0,7,1,4,5,0,2,0,0],[0,0,0,0,0,0,1,6,0,0,3,2,0,5,0,0,4,8,7,0,0,0,9,0,0],[3,8,0,9,0,9,5,6,7,2,0,1,10,10,9,4]]
    li2 = [[0,0,0,0,0,0,0,0,2,5,4,6,7,8,1,3],[0,0,0,0,0,0,2,5,6,0,0,4,0,3,0,0,8,7,1,0,0,0,9,0,0],[0,7,8,9,3,9,1,0,4,5,0,2,10,10,9,6]]
    for i in range(3):
        T = i
        write(0,li1[i])
        write(len(li1[i]),li2[i])
    write(1,[1,2,3,4,5,6,7,8],b=False)
writing_init_temp()         # temp
    
root = []
leaf = []
info = [-1,-1,-1]
for i in range(3):
    T = i
    y,x = [2,5,4][i],[8,5,4][i]
    for j in range(2):
        m = leaf if j else root
        m.append(read(y * x * j,y,x))

def con(m):
    m = ['x' if i == 9 else '0' if i == 10 else str(i) for i in m]
    if T < 2:
        if T == 1:
            li = read(0,5,5)
            li = [i for i in range(len(li)) if li[i] == 9]
            li = [0,1,3,4,5,9,12,15,19,20,21,23,24]+li
        else:
            li = [1,3,4,6]
        m = ['x' if i in li else m[i] for i in range(len(m))]
    return ''.join(m)
for i in range(3):
    T = i
    if i == 2:
        info[i] = [j for j in range(16) if root[i][j] == 10]
    root[i] = con(root[i])
    leaf[i] = con(leaf[i])

def ps(pos,y,x,sy=50,sx=50):
    s = y * x
    pos = [pos] * s
    for i in range(1,s):
        if i % x:
            pos[i] = tr(pos[i - 1],[-sx,0,0,0,0,0])
        else:
            pos[i] = tr(pos[i-x],[0,sy,0,0,0,0])
    return pos
elcA=[posx(213.29, 321.15, 226.21, 179.8, 90, 90),-1,posx(113.04, 321.48, 225.85, 0.01, -90, -90),-1,-1,posx(-36.31, 322.06, 225.29, 0.15, -90, -90),-1,posx(-136.02, 322.11, 224.96, 0.5, -89.99, -90.09),
posx(213.49, 420.89, 226.59, 179.91, 90, 90),posx(163.79, 421.77, 226.34, 180, 90, 90),posx(113.86, 420.81, 226.08, 0.22, -90, -90),posx(63.84, 421.98, 225.99, 0.28, -90, -90),posx(13.93, 421.62, 225.81, 0.61, -90, -90),posx(-35.46, 422.06, 225.85, 0.76, -89.97, -89.97),posx(-85.31, 422.68, 225.76, 1.01, -89.96, -89.97),posx(-134.97, 422.26, 225.65, 1.25, -90, -90)]
airA=[posx(213.6, 321.12, 141.53+59, 179.39, 90, -90),-1,posx(113.67, 321.26, 141.53+59, 179.67, 89.95, -89.91),-1,-1,posx(-35.68, 322.04, 141.54+59, 179.67, 89.95, -89.91),-1,posx(-135.29, 322.65, 141.53+59, 179.67, 89.95, -89.91)]+\
ps(posx(213.84, 420.99, 142.17+59, 179.49, 89.99, -89.98),1,2)+ps(posx(114.33, 421.31, 142.36+59, 179.55, 90, -90),1,2)+ps(posx(14.31, 421.48, 141.42+59, 179.78, 89.99, -89.97),1,2)+ps(posx(-85.5, 422.18, 141.7+59, 0.01, -90, 89.97),1,2)
poss = [
[elcA,ps(posx(-246.12, 323.04-100, 225.65, 0.02, -90, -89.95),5,5),ps(posx(446.44, 228.84, 226.51, 179.69, -90.04, -90.04),4,4)],
[airA,ps(posx(-245.88, 323.82-100, 140.54+60, 0.24, -90, 90),5,5),ps(posx(446.04, 228.04, 199.57, 179.81, -90, 90),4,4)]]

def mt1(p,g,d=[],mod=0,h=-1,z=0,a1=3000,a2=[2500,1000][tool],b1=True,b2=False):
    tp = tr(pos[p],[0,0,-([0,0.6][not g and not tool]+z),0,0,0])
    ml(up(tp,mod,h),a=a1)
    if b2:
        return -1
    ml(tp,a=a2,r=5)
    grip(g)
    if d:
        ad,val = d
        write(ad,val)
    if b1:
        ml(up(tp),a=a1)
def mt2(p):
    n1 = [i for i in read(1,1,8,b=False)].index(p)
    if T == 0:
        it(4 - n1)
    else:
        n2 = [i for i in read(124,1,8,b=False)].index(p)
        t1 = it(4 - n1,0)
        t2 = gt(1 +  n2,0)
        t = t2 if t1 < t2 else t1
        wait(t)

def Run():
    if T == 1:
        mjx(up(pos[20]))
    if T == 2:
        mjx(up(pos[15],h=360))
    for i in range(len(res)):
        r = res[i]
        b4 = T == 2 and len(r[0]) > 2
        if b4:
            s,e = r[0][0],r[0][-1]
            road = r[0][1:-1]
        else:
            s,e = r[0]
        p = r[1]       
        af = res[i+1][1] if i < len(res)-1 else -1
        bf = res[i-1][1] if i else -1
        b1,b2 = p == af,p == bf
        b3 = T == 0 and ((s in [7,8] and e in [7,8]) or abs(s - e) not in [1,8])
        if not b2:
            mt2(p)      # index, gantry pack marking
            li = [[8,9,10,11,12,13,14,15],[6,7,8,11,13,16,17,18],[5,6,9,10]][T]      # blue area
            cht(n = 0 if s in li else 1)      # not blue area -> air gripper
            z = [0,20 if p in [1,2,7,8] else 10 if p in [3,4] else 0][tool]         # height control
            mt1(s,1,[s,0],z=z,b1=False)
            rml(z=3,acc=800)
        if b3:      # ride line
            n = lambda pos:[-50,50][pos < 8]
            rml(y = n(s))
            ml(up(tr(pos[e],[0,n(e),-z,0,0,0]),1,3),a=4000)
        if b4:      # ride hole
            for i in road:
                mt1(i,0,[],1,3,z,1500,b2=True)
        mt1(e,0,[e,p],1,3,z,[None,1500][b1],800,b2=b1)
        
write(30,1,b=False)
import time         # temp
time_start = time.time()        # temp

ress = [
[[[13, 14], 2], [[14, 15], 2], [[8, 7], 7], [[0, 8], 6], [[15, 0], 2], [[8, 15], 6], [[9, 8], 1], [[10, 9], 4], [[11, 10], 5], [[15, 14], 6], [[8, 15], 1], [[9, 8], 4], [[10, 9], 5], [[14, 13], 6], [[15, 14], 1], [[8, 15], 4], [[9, 8], 5], [[13, 12], 6], [[14, 13], 1], [[15, 14], 4], [[2, 15], 3], [[8, 2], 5], [[15, 8], 3], [[14, 15], 4], [[13, 14], 1], [[12, 13], 6], [[8, 9], 3], [[9, 10], 3], [[10, 11], 3], [[15, 8], 4], [[14, 15], 1], [[8, 9], 4], [[15, 8], 1], [[9, 10], 4], [[8, 9], 1], [[9, 8], 1], [[10, 9], 4], [[5, 15], 8], [[8, 5], 1], [[9, 8], 4], [[15, 14], 8], [[8, 15], 4], [[5, 8], 1], [[8, 9], 1], [[9, 10], 1], [[15, 5], 4], [[14, 15], 8], [[15, 8], 8], [[8, 9], 8], [[7, 8], 7], [[13, 14], 6], [[14, 15], 6], [[15, 7], 6], [[11, 12], 3], [[12, 13], 3], [[13, 14], 3], [[14, 15], 3], [[10, 11], 1], [[11, 12], 1], [[12, 13], 1], [[13, 14], 1], [[9, 10], 8], [[10, 11], 8], [[11, 12], 8], [[12, 13], 8], [[8, 9], 7], [[9, 10], 7], [[10, 11], 7], [[11, 12], 7], [[7, 8], 6], [[8, 9], 6], [[9, 10], 6], [[10, 11], 6], [[5, 8], 4], [[8, 9], 4], [[9, 10], 4], [[2, 8], 5], [[8, 9], 5], [[0, 8], 2]],
[[[13, 8], 5], [[18, 13], 7], [[13, 14], 7], [[17, 18], 8], [[16, 17], 4], [[11, 16], 2], [[6, 11], 1], [[7, 6], 6], [[8, 7], 5], [[7, 2], 5], [[6, 7], 6], [[11, 6], 1], [[7, 8], 6], [[6, 7], 1], [[16, 11], 2], [[11, 6], 2], [[10, 11], 3], [[8, 13], 6], [[7, 8], 1], [[6, 7], 2], [[11, 6], 3], [[17, 16], 4], [[16, 11], 4], [[11, 10], 4], [[18, 17], 8], [[13, 18], 6], [[14, 13], 7], [[6, 11], 3], [[7, 6], 2], [[8, 7], 1], [[13, 8], 7], [[18, 13], 6], [[11, 16], 3], [[6, 11], 2], [[7, 6], 1], [[8, 7], 7], [[13, 8], 6], [[17, 18], 8], [[18, 13], 8], [[13, 14], 8], [[8, 13], 6], [[7, 8], 7], [[13, 18], 6], [[14, 13], 8], [[8, 7], 7], [[13, 8], 8], [[18, 13], 6], [[16, 17], 3], [[11, 16], 2], [[6, 11], 1], [[7, 6], 7], [[8, 7], 8], [[13, 8], 6], [[17, 18], 3], [[18, 13], 3], [[16, 17], 2], [[11, 16], 1], [[6, 11], 7], [[7, 6], 8], [[8, 7], 6], [[13, 8], 3], [[17, 18], 2], [[18, 13], 2], [[13, 14], 2], [[8, 13], 3], [[7, 8], 6], [[6, 7], 8], [[13, 18], 3], [[8, 13], 6], [[7, 8], 8], [[18, 17], 3], [[13, 18], 6], [[14, 13], 2], [[8, 7], 8], [[7, 6], 8], [[13, 8], 2], [[8, 7], 2], [[18, 13], 6], [[17, 18], 3], [[16, 17], 1], [[11, 16], 7], [[6, 11], 8], [[7, 6], 2], [[13, 8], 6], [[18, 13], 3], [[17, 18], 1], [[16, 17], 7], [[11, 16], 8], [[2, 7], 5], [[10, 11], 4]],
[[[11, 10], 1], [[7, 11], 6], [[6, 2], 5], [[10, 6], 1], [[11, 7], 6], [[15, 11], 4], [[11, 10], 4], [[7, 11], 6], [[11, 15], 6], [[10, 11], 4], [[9, 10], 2], [[11, 7], 4], [[10, 11], 2], [[6, 10], 1], [[7, 6], 4], [[0, 4], 3], [[1, 0], 8], [[2, 1], 5], [[6, 2], 4], [[10, 6], 1], [[8, 12, 13, 9], 7], [[4, 8], 3], [[0, 4], 8], [[1, 0], 5], [[2, 1], 4], [[6, 2], 1], [[9, 10], 7], [[10, 6], 7], [[6, 7], 7], [[8, 12, 13, 9], 3], [[4, 8], 8], [[0, 4], 5], [[1, 0], 4], [[2, 1], 1], [[9, 10], 3], [[10, 6], 3], [[6, 2], 3], [[7, 6], 7], [[6, 10], 7], [[2, 6], 3], [[1, 2], 1], [[10, 9], 7], [[6, 10], 3], [[2, 6], 1], [[6, 7], 1], [[0, 1], 4], [[4, 0], 5], [[1, 2], 4], [[0, 1], 5], [[8, 4], 8], [[4, 0], 8], [[2, 6], 4], [[1, 2], 5], [[0, 1], 8], [[9, 8], 7], [[10, 9], 3], [[6, 10], 4], [[2, 6], 5], [[1, 2], 8], [[8, 4], 7], [[9, 8], 3], [[10, 9], 4], [[6, 10], 5], [[7, 6], 1], [[4, 0], 7], [[0, 1], 7], [[8, 4], 3], [[9, 8], 4], [[10, 9], 5]]]
#ress = []
#for i in range(3):
    #if info[i] != -1:
        #ress.append(main(i,root[i],leaf[i],info[i]))
    #else:
        #ress.append(main(i,root[i],leaf[i]))
    #tl(i,'done !!!')
    
for i in range(3):
    grip(0)
    if i == 2:      # tool rotations reset
        mj([90,0,90,90,90,0])
        tool = 0
    T,pos,res = i,poss[tool][i],ress[i]
    Run()
    
write(30,1,b=False)
time_end = time.time() - time_start         # temp
minute,second = int(time_end // 60),int(time_end % 60)         # temp
tl('{}m {}s\n'.format(minute,second))         # temp