def exc(m,s,e,li=-1):
    m = list(m)
    m[s],m[e] = m[e],m[s]
    step = [e,s] if li == -1 else li
    return [''.join(m),[step,int(m[s])]]
def aro(pos):
    if pos in cache:
        return cache[pos]
    res = []
    if t:
        dy,dx = [-1,0,1,0],[0,1,0,-1]
    else:
        dy = [-1]*15+[0,0]+[1]*15+[0,0]
        dx = list(range(-7,8))+[1,7]+list(range(-7,8))+[-1,-7]
    y,x = divmod(pos,sx)
    for i in range(len(dy)):
        ny,nx = y + dy[i],x + dx[i]
        if -1 < ny < sy and -1 < nx < sx:
            res.append(ny * sx + nx)
    cache[pos] = res
    return res
def exp(n,m,pos=-1,pack=-1):
    res = []
    for i in range(size) if n > 0 else [pos]:       
        if (n > 0 and m[i] != '0') or i in fix:
            continue
        if t == 2 and n > 0 and i in hli:
            continue        
        for j in aro(i):
            b1 = lambda i: m[i] in (['0x','x'][t == 2] if n > 0 else 'x') or i in fix
            b2 = lambda i,j: n == 2 and i == pos and m[j] not in ['0',pack]
            if b1(j) or b2(i,j):
                continue
            if t == 0:
               if (abs(i-j) == 7 and i < 8) or \
                   (j < 8 and i not in [8,15]) or (i < 8 and j not in [8,15]):
                    continue
            if t == 2 and n > 0:
                if j in hli:
                    que = deque([j])
                    mkd = {j:i,i:-1}
                    while que:
                        cur = que.popleft()
                        for k in aro(cur):
                            if k not in mkd:
                                mkd[k] = cur
                                if k in hli:
                                    que.append(k)
                                if m[k] == '0' or b1(k) or b2(i,k):
                                    continue
                                res1 = path(mkd,mkd,k)+[k]
                                res.append(exc(m,i,k,res1[::-1]))
                if m[j] == '0':
                    continue
            res.append(exc(m,i,j) if n > 0 else [j,j])
    return res
def bfs(n,m,*a):
    global res    
    if n == -1:
        leaf,s,li = a 
    if n == 0:
        s,e = a
    if n == 1:
        leaf,pos,pack = a
    if n in [2,3]:
        pos,pack = a
    if n == 4:
        li1,li2 = a        
    cur = m if n > 0 else s
    que = deque([cur])
    mkd,step = {cur:-1},{cur:-1}
    while 1:
        cur = que.popleft()
        if n == -1 and leaf[cur] != '0' and cur not in li:
            break
        if n == 0 and cur == e:
            break
        if n in [1,2]:
            if (pos == -1 and cur == leaf) or\
               (pos != -1 and cur[pos] == pack):
                break
        if n == 3 and cur[pos] not in ['0',pack]:
            break
        if n == 4 and [cur[i] for i in li1] == li2:
            break
        for i,j in exp(n,cur if n > 0 else m,
                       cur if n < 1 else pos if n == 2 else -1,
                       pack if n == 2 else -1):
            if i not in mkd:
                que.append(i)
                mkd[i],step[i] = cur,j                
    res1 = path(mkd,step,cur)    
    if n > 0 :
        res += res1
        return cur
    return res1
def path(mkd,step,cur):
    path = [step[cur]]
    while mkd[cur] != -1:
        cur = mkd[cur]
        path.append(step[cur])
    return path[::-1][1:]
def sort(m,leaf,e,p=-1):
    pack = leaf[e] if p == -1 else p
    s = m.index(pack)
    r = bfs(0,m,s,e)
    if t == 2:
        r = [i for i in r if i not in hli]        
    for i in r:
        m = bfs(1,m,leaf,i,pack)
    fix.append(e)
    return m
def main(g_t,m,*a):    
    global t,sy,sx,size,fix,res,cache
    t = g_t
    sy,sx = [[2,8],[5,5],[4,4]][t]
    size = sy * sx
    fix = []
    res = []
    cache = {}
    if t == 0:
        leaf, = a
        for i in range(2):
            m = sort(m,leaf,[0,2][i],leaf[8+i])
        for i in [11,12]:
            m = bfs(1,m,leaf,i,'0')
            fix.append(i)
        fix = fix[:-2]        
        for i in range(4):
            m = sort(m,leaf,11-i,leaf[15-i])
        for i in range(4):
            m = bfs(1,m,leaf,12+i,'0')
            fix.append(12+i)
        for i in range(2):
            fix = [] if i else [0,2,5,7]
            for j in range(4):
                m = sort(m,leaf,[15,11][i]-j)
    if t == 1:
        leaf, = a
        li = [2,10,14,22]
        di = {2:7,10:11,14:13,22:17}
        hold = {}
        for i in range(2):
            fix = [hold[j] for j in hold]
            pos = [j for j in li if j not in fix and m[j] != 'x'][0]
            pack = leaf[di[pos]]
            for j in li:
                if j not in fix+[pos]:
                    m = bfs(3,m,j,pack)
                    fix.append(j)
            m = bfs(2,m,pos,pack)
            hold[di[pos]] = pos
            fix = [hold[j] for j in hold]            
        inli = [7,8,13,18,17,16,11,6]
        pos1 = [i for i in li if i not in fix and m[i] != 'x'][0]
        pos = [i for i,j in exp(0,m,pos1) if i in inli][0]
        pos3,pos2 = [inli[(inli.index(pos)-i)%8] for i in range(2)]
        m = bfs(1,m,leaf,pos1,'0')
        leafli = [leaf[i] for i in inli if i not in hold and leaf[i] != '0']
        n = leafli.index(m[pos3])
        leafli = [leafli[(n + i) % 6] for i in range(6)]    
        for pack in leafli:
            curli = [m[i] for i in inli if m[i] in leafli]
            n = leafli.index(pack)-1
            bpack = leafli[n % len(curli)]
            n = curli.index(pack)-1
            if curli[n % len(curli)] == bpack:
                continue
            m = bfs(2,m,pos1,pack)
            for i in range(2):
                edit = fix.remove if i else fix.append
                edit(pos1)
                m = bfs(1,m,leaf,[pos2,pos3][i],[bpack,pack][i])
                edit(pos2)  
        fix = li[:]        
        for i in inli[::-1]:
            if i not in hold and leaf[i] != '0':
                m = bfs(1,m,leaf,i,leaf[i])
                fix.append(i)
        fix = []
        bfs(1,m,leaf,-1,-1)
    if t == 2:
        global hli
        leaf,hli = a        
        hold = {}
        xli = [i for i in range(16) if m[i] == 'x']
        pos = [i for i in [5,6,9,10] if i in xli]
        vt = {5:15,6:12,9:3,10:0}
        if pos:
            pos = pos[0]
            outli = {5:[3,12,7,13,15,14,11], 6:[0,15,4,14,12,13,8], 9:[0,15,1,11,3,2,7], 10:[3,12,2,8,0,1,4]}[pos]
            inli = {5:[1,2,6,10,9,8,4,0], 6:[2,3,7,11,10,9,5,1], 9:[5,6,10,14,13,12,8,4], 10:[6,7,11,15,14,13,9,5]}[pos]
            b = lambda n:n not in hli and n !=vt[pos] and m[n] != 'x'
            pos1 = [i for i in outli if leaf[i] == '0' and b(i)]
            pos1 = pos1[0] if pos1 else [i for i in outli if b(i)][0]
            for i in outli:
                if i not in hli+[pos1] and m[i] !='x':
                    if i in hold or leaf[i] == '0':
                        pos2 = bfs(-1,m,leaf,i,hold)[-1]
                        m = sort(m,leaf,i,leaf[pos2])
                        hold[pos2] = i
                    else:
                        m = sort(m,leaf,i)
            m = bfs(1,m,leaf,pos1,'0')
            leafli = [leaf[i] for i in inli if i not in hold and leaf[i] != '0']
            for pack in leafli:
                curli = [m[i] for i in inli if m[i] in leafli]
                n = leafli.index(pack)-1
                bpack = leafli[n % len(curli)]                
                n = curli.index(pack)-1                
                if curli[n % len(curli)] == bpack:
                    continue                
                m = bfs(2,m,pos1,pack)
                pos = [i for i,j in exp(0,m,pos1) if i in inli][0]
                n = inli.index(pos)
                res1 = []
                for i in range(2):
                    li = [inli[(n + [-j,j][i]) % 8] for j in range(8)]
                    res1.append([j for j in li[1-i:] if j not in hli][0])                    
                pos2,pos3 = res1
                for i in range(2):
                    edit = fix.remove if i else fix.append
                    edit(pos1)
                    m = bfs(1,m,leaf,[pos2,pos3][i],[bpack,pack][i])
                    edit(pos2)                    
            if pos1 in hold:
                fix.remove(hold[pos1])
            m = bfs(2,m,pos1,leaf[pos1])
            fix.append(pos1)
            if pos1 in hold:
                fix.append(hold[pos1])
            for i in inli:
                if i not in hold and leaf[i] != '0':
                    m = bfs(1,m,leaf,i,leaf[i])
                    fix.append(i)
            fix = []
            bfs(1,m,leaf,-1,-1)            
        else:
            unhold = []
            for i in [[0,1,4,3,7,12,13],[3,2,7,0,4,15,14],[12,13,8,0,1,15,11],[15,14,11,3,2,12,8]]:
                if 'x' not in [leaf[j] for j in i[:3]]:
                    li1 = i
            ct = 0
            for i in li1:
                if i not in hli and m[i] != 'x' and ct < 4:
                    if i in hold or leaf[i] == '0':
                        pos = bfs(-1,m,leaf,i,hold)[-1]
                        m = sort(m,leaf,i,leaf[pos])
                        hold[pos] = i
                        unhold.append(pos)
                    else:
                        m = sort(m,leaf,i)
                    ct += 1            
            li1 = [i for i in range(16) if i not in fix and i not in hold]
            li2 = [leaf[i] for i in li1]         
            m = bfs(4,m,li1,li2)
            for i in unhold[::-1]:
                fix.remove(hold[i])
                m = bfs(1,m,leaf,i,leaf[i])
                fix.append(i)            
    return res
    
from collections import deque
drl_report_line(OFF)
tl = lambda *n:tp_log(' '.join(map(str,n)))
set_tool('tool wei')
set_velx(1000); set_accx(2000)
set_velj([100,150,180,225,225,225]); set_accj(400)
begin_blend(10)
ml,mj,aml,amj,tr,wt = movel,movej,amovel,amovej,trans,wait
def mjx(pos,sol=-1):
    movejx(pos,sol = sol if sol != -1 else (3 if T == 2 else 2))
def rml(x=0,y=0,z=0,a=0,b=0,c=0,t=0.1,vel=None,acc=None):
    aml([x,y,z,a,b,c],mod=1,v=vel,a=acc)
    wt(t)
def rmj(x=0,y=0,z=0,a=0,b=0,c=0,t=0.1,acc=None):
    amj([x,y,z,a,b,c],mod=1,a=acc)
    wt(t)
def up(pos,mod=0,h=-1):
    pos,h = pos[:],h if h != -1 else 260
    pos[2] = pos[2] + h if mod else h
    return pos
tool = 0
def cht(t=0.6,n = -1):
    global tool,pos
    if n==tool:
        return -1
    tool = (1 - tool)
    li = [180,-180] if T == 2 else [-180,180]
    rmj(c=li[0] if tool else li[1],t=t,acc=1500)
    pos = poss[tool][T]
isgrip = 0
def grip(n):
    global isgrip
    isgrip = n
    if tool:
        if not n:
            wt(0.1)
        write(40,n,b=0)
    else:
        set_tool_digital_outputs([1,-2] if n else [-1,2])
    wt(0.25)
def it(n,t=0.3):
    write(10,n,b=0)
    wt(t * abs(n))
    return 0.3 * abs(n)
gp = 4.5
def gt(n,t=0):
    global gp
    gp = n
    write(20,n,b=0)
    wt(t * abs(gp - n))
    return 0 * abs(gp - n)
        
ser=serial_open('COM')
def ts(ad,m=[],y=0,x=0,b=1):
    if b:
        ad+=100*(T+1)
    k='00'+['R','W'][not y]+'SB06%DW'
    k=[ord(i) for i in k]
    n=len(m) if not y else y*x
    ad = [0]*(3-len(str(ad))) + list(map(int,str(ad)))
    k+=[ord(str(abs(i))) for i in ad]
    k+=[ord(i) for i in '{:02X}'.format(n)]
    if not y:
        for i in m:
            if i<0:
                i+=2**16
            k+=[ord(j) for j in '{:04X}'.format(i)]
    ser.write([5]+k+[4])
    wt(0.02 if n == 1 else 0.05)
    k=ser.read(ser.inWaiting())
    if y:
        for i in range(0,y*x*4,4):
            n=int(k[10+i:14+i],16)
            if n&(2**15):
                n-=2**16 
            m.append(n)
        return m if len(m) > 1 else m[0]
def write(*a,b=1):
    if isinstance(a[0],int):
        a = [a]
    for i,j in a:
        ts(i,[j] if isinstance(j,int) else j,b=b)
def read(ad,y=1,x=1,b=1):
    return ts(ad,[],y,x,b=b)
    
root=[-1]*3    
leaf=[-1]*3
info=[-1]*3
for i in range(3):
    T = i
    y,x = [2,5,4][i],[8,5,4][i]
    for j in range(2):
        m=read(y*x*j,y,x)[:]
        if j:
            leaf[i]=m[:]        
        else:
            root[i]=m[:]

def con(m):
    m = ['x' if i == 9 else '0' if i == 10 else str(i) for i in m]
    if T < 2:
        if T == 1:
            li = read(0,5,5)
            li = [i for i in range(25) if li[i] == 9]
            li = [0,1,3,4,5,9,12,15,19,20,21,23,24]+li
        else:
            li = [1,3,4,6]
        m = ['x' if i in li else m[i] for i in range(len(m))]
    return ''.join(m)
for i in range(3):
    T = i
    if i == 2:
        info[i] = [j for j in range(16) if root[i][j] == 10]
    root[i] = con(root[i])
    leaf[i] = con(leaf[i])

def ps(pos,y,x,sy=50,sx=50,err={}):
    s = y * x
    pos = [pos] * s
    for i in range(1,s):
        if i % x:
            pos[i] = tr(pos[i - 1],[-sx,0,0,0,0,0])
        else:
            pos[i] = tr(pos[i-x],[0,sy,0,0,0,0])
        if i in err:
            pos[i]=tr(pos[i],[0,0,err[i],0,0,0])
    return pos
elcA=ps(None,2,8,100)
elcB=ps(None,5,5)
elcC=ps(None,4,4)
airA=ps(None,2,8,100)
airB=ps(None,5,5)
airC=ps(None,4,4)
poss=[[elcA,elcB,elcC],[airA,airB,airC]]

def mt1(p,g,d=[],mod=0,h=-1,z=0,a1=3000,a2=2500,b1=1,b2=0):
    tp = tr(pos[p],[0,0,-z,0,0,0])
    ml(up(tp,mod,h),a=a1)
    if b2:
        return -1
    ml(tp,a=a2,r=5)
    grip(g)
    if d:
        ad,val = d
        write(ad,val)
    if b1:
        ml(up(tp),a=a1)
def mt2(p):
    n1 = [i for i in read(1,1,8,b=0)].index(p)
    if T == 0:
        it(4 - n1)
    else:
        n2 = [i for i in read(124,1,8,b=0)].index(p)
        t1 = it(4 - n1,0)
        t2 = gt(1 +  n2,0)
        wt(t1 if t1 > t2 else t2)

def Run():
    if T == 1:
        mjx(up(pos[20]))
    if T == 2:
        mjx(up(pos[15],h=360))
    for i in range(len(res)):
        r = res[i]
        b3 = T == 2 and len(r[0]) > 2
        if b3:
            s,e = r[0][0],r[0][-1]
            road = r[0][1:-1]
        else:
            s,e = r[0]
        p = r[1]       
        af = res[i+1][1] if i < len(res)-1 else -1
        bf = res[i-1][1] if i else -1
        b1,b2 = p == af,p == bf
        b4 = T == 0 and ((s in [7,8] and e in [7,8]) or abs(s - e) not in [1,8])
        if not b2:
            mt2(p)
            li = [[8,9,10,11,12,13,14,15],[6,7,8,11,13,16,17,18],[5,6,9,10]][T]
            cht(n = 0 if s in li else 1)
            z = [0,20 if p in [1,2,7,8] else 10 if p in [3,4] else 0][tool]
            mt1(s,1,[s,0],z=z,b1=0)
            rml(z=3,acc=500)
        if b4:
            n = lambda pos:[-50,50][pos < 8]
            rml(y = n(s))
            ml(up(tr(pos[e],[0,n(e),-z,0,0,0]),1,3),a=4000)
        if b3:
            for i in road:
                mt1(i,-1,[],1,3,z,1500,b2=1)
        mt1(e,0,[e,p],1,3,z,[None,1500][b1],500,b2=b1)
        
write(30,1,b=0)
ress = []
for i in range(3):
    if i==2:
        ress.append(main(i,root[i],leaf[i],info[i]))
    else:
        ress.append(main(i,root[i],leaf[i]))  
for i in range(3):
    grip(0)
    if i == 2:
        mj([90,0,90,90,90,0])
        tool = 0
    T,pos,res = i,poss[tool][i],ress[i]
    Run()    
write(30,1,b=0)