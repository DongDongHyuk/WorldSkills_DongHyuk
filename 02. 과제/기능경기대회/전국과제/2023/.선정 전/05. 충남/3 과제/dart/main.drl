'''
0. algorithm
1. header
2. device communication
 - reading init
 - converting init
 - positions
 - motion
3. main
'''

# 0. Algorithm
def exc(m,s,e,li=-1):
    m = list(m)
    m[s],m[e] = m[e],m[s]
    step = [e,s] if li == -1 else li
    pack = int(m[s])
    info = [step,pack]
    m = (''.join(m),pack) if t == 2 else ''.join(m)
    return [m,info]
    
def aro(pos):
    if pos in cache:
        return cache[pos]
    res = []
    dy,dx = [-1,0,1,0],[0,1,0,-1]
    y,x = divmod(pos,sx)
    for i in range(4):
        ny,nx = y + dy[i],x + dx[i]
        if -1 < ny < sy and -1 < nx < sx:
            res.append(ny * sx + nx)
    cache[pos] = res
    return res

def exp(n,m,pos=-1):
    res = []
    if t == 2:
        m,p = m
    for i in range(size)[(4 if t == 1 else 0):] if n > 0 else [pos]:
        if (n > 0 and m[i] != '0') or i in fix:
            continue
        if t == 1 and (m[i] != '0' or m[i-4] == '0'):       # 3 차원 조건
            continue
        if t == 1:
            li = []
            for x in range(4):
                for z in range(4):
                    pos = z * 4 + x
                    if m[pos] != '0' and (z == 3 or (pos + 4 != i and m[pos+4] == '0')):
                        li.append(pos)
                        break
        if t == 2:
            li = [j % 8 for j in [i-3,i-2,i-1,i+1,i+2,i+3]]
        for j in [j for j in (li if t in [1,2] else aro(i))
                  if m[j] not in ['x','0x'][n > 0] and j not in fix]:
            if t == 0 and n == -1 and m[j] != '0':      #       
                continue
            if t == 2 and m[j] == p:        # 이전에 잡았던 팩
                continue
            res.append(exc(m,i,j) if n > 0 else [j,j])
    return res

def bfs(n,m,*a):
    global res
    if n < 1:
        s,e = a
    if n == 1:
        leaf,pos,pack = a
    cur = m if n > 0 else s
    que = deque([cur])
    mkd,step = {cur:-1},{cur:-1}
    while 1:
        cur = que.popleft()
        if n < 1 and cur == e:
            break
        if n == 1:
            cur1 = cur[0] if t == 2 else cur
            if (pos == -1 and cur1 == leaf) or \
               (pos != -1 and cur1[pos] == pack):
                break
        for i,j in exp(n,cur if n > 0 else m,cur):
            if i not in mkd:
                que.append(i)
                mkd[i],step[i] = cur,j
    mkd[-2] = cur
    path = [step[cur]]
    while mkd[cur] != -1:
        cur = mkd[cur]
        path.append(step[cur])
    if n > 0:
        res += path[::-1][1:]
        return mkd[-2]
    return path[::-1][1:]

def main(g_t,m,*a):    
    global t,sy,sx,size,fix,res,cache
    t = g_t
    sy,sx = [[4,5],[4,4],[1,8]][t]
    size = sy * sx
    fix = []
    res = []
    cache = {}      # cache reset
    if t == 0:
        s,e,li = a
        if e == -1:
            di = {}
            for i in range(4):
                e = li[i]
                try:
                    fix = [i for i in li if i != e]
                    di[e] = len(bfs(-1,m,s,e))
                except:
                    pass
            res = min(di,key = lambda n:di[n])  
        else:
            res = [s]+bfs(0,m,s,e)
    if t == 1:
        li, = a
        fix = [0,1,2,3]
        leaf = [m[i] for i in [0,1,2,3]]+['0']*12
        for i in range(4):
            pack = leaf[i]
            for j in range(li[i]-1):
                pos = 4 + i + (4 * j)
                leaf[pos] = pack
        leaf = ''.join(leaf)    
        for i in [4,8,12]:
            m = bfs(1,m,leaf,i,leaf[i])
            fix.append(i)            
        m = bfs(1,m,leaf,-1,-1)        
    if t == 2:
        leaf = ['x' if i == 'x' else '0' for i in m]
        pos = 0
        for i in '112233':
            if leaf[pos] == 'x':
                pos += 1
            leaf[pos] = i
            pos += 1
        leaf = ''.join(leaf)
        m = bfs(1,(m,-1),leaf,-1,-1)
    return res

# 1. header
tl = lambda *n:tp_log(' '.join(map(str,n)))
from collections import deque
drl_report_line(OFF)
set_tool('tool wei'); set_tcp('tcp')
set_velx(1000); set_accx(2000)
set_velj([100,150,180,225,225,225]); set_accj(350)
begin_blend(10)
ml,mj,aml,amj,tr,wt = movel,movej,amovel,amovej,trans,wait
def mjx(pos,sol=-1):
    movejx(pos,sol = sol if sol != -1 else 2)
def rml(x=0,y=0,z=0,a=0,b=0,c=0,t=0.1,vel=None,acc=None):
    aml([x,y,z,a,b,c],mod=1,v=vel,a=acc)
    mwait(0) if t is -1 else wait(t)
def rmj(x=0,y=0,z=0,a=0,b=0,c=0,t=0.1,acc=None):
    amj([x,y,z,a,b,c],mod=1,a=acc)
    mwait(0) if t is -1 else wait(t)
def up(p,mod=0,h=-1):
    p,h = p[:],h if h != -1 else [260,300][T]
    p[2] = p[2] + h if mod else h
    return p
tool = 0
def cht(t=0.6,n = -1):
    global tool,pos
    if n != -1 and n == tool:
        return -1
    tool = (1 - tool)
    rmj(c=-180 if tool else 180,t=t,acc=1500)
    pos = poss[tool][T]
isgrip = False
def grip(n):
    global isgrip
    isgrip = n
    if tool:
        if not n:
            wt(0.1)
        write(40,n,b=False)
        wt(0.15)
    else:
        set_tool_digital_outputs([1,-2] if n else [-1,2])
        wt(0.25)
itli = lambda:read(1,1,8,b=False)
itps = deque([0,1,2,3,4,5,6,7])
def it(n,t=0.6):
    write(10,n,b=False)
    wt(t * abs(n))
    itps.rotate(n)    
gp = -1
def gt(n,t=3):
    global gp
    if n == gp:
        return -1
    write(20,n,b=False)
    wt(t *  abs(gp - n))
    gp = n
        
# 2. device communication
ser=serial_open("COM")
def ts(ad,m=[],y=0,x=0,b=True):
    if b:
        ad += 100 * (1 + T)
    k='00'+['W','R'][bool(y)]+'SB06%DW'
    k=[ord(i) for i in k]
    n=len(m) if not y else y*x
    ad = [0]*(3-len(str(ad))) + list(map(int,str(ad)))
    k+=[ord(str(abs(i))) for i in ad]
    k+=[ord(i) for i in '{:02X}'.format(n)]
    if not y:
        for i in m:
            if i<0:
                i+=2**16
            k+=[ord(j) for j in '{:04X}'.format(i)]
    ser.write([5]+k+[4])
    wait(0.02 if n is 1 else 0.05)
    k=ser.read(ser.inWaiting())
    if y:
        for i in range(0,y*x*4,4):
            v=int(k[10+i:14+i],16)
            if v&(1<<15):
                v-=2**16 
            m.append(v)
        return m if len(m) > 1 else m[0]
def write(*a,b = True):
    if isinstance(a[0],int):
        a = [a]
    for i,j in a:
        ts(i,j if isinstance(j,list) else [j],b=b)
def read(ad,y=1,x=1,b=True):
    return ts(ad,[],y,x,b)
    
# - writing init        temp
def writing_init_temp():
    global T
    li1 = [[102,6,0,9,7,2,4,0,3,0,0,9,0,8,1,0,0,9,5,101,11,13,12,14],[2,2,3,1,3,0,1,0,0,0,0,0,0,0,0,0,2,2,3,3]]
    for i in range(2):
        T = i
        write(0,li1[i])
    write(1,[10,10,10,0,10,10,10,9],b=False)
    #write(1,[1,1,2,2,3,3,0,9],b=False)
writing_init_temp()         # temp

# - reading init
root = []
info = [-1]*2
for i in range(2):
    T = i
    y,x = [4,4][i],[5,4][i]
    root.append(read(0,y,x))
        
# - converting init
def con(m):
    m = ['x' if i == 9 else '0' if i > 4 else str(i) for i in m]
    return ''.join(m)
for i in range(2):
    T = i
    if not i:
        li1 = []
        for j in [5,6,7,8]:
            li1.append(root[i].index(j))
        li2 = [j for j in range(20) if root[i][j] > 100][::-1]
        li = [li1,li2]
    else:
        li = read(16,1,4)
    info[i] = li[:]
    root[i] = con(root[i])
    
# - get positions
def ps(pos,y,x,z=1,sy=40,sx=40,sz=20):
    s1 = y * x
    s2 = s1 * z
    pos = [pos] * s2
    for i in range(1,s2):
        if not i % s1:
            pos[i] = tr(pos[i-s1],[0,0,sz,0,0,0])
        elif i % x:
            pos[i] = tr(pos[i - 1],[-sx,0,0,0,0,0])
        else:
            pos[i] = tr(pos[i-x],[0,sy,0,0,0,0])
    return pos
poss = [
[ps(posx(-360.95, 56.87, 230.17, 89.79, -90, -90),4,5),
None],
[None,
ps(posx(68.37, 393.63, 185.02-20, 0.71, -90, 90),1,4,4,sx = 22)]] 
A1 = ps(posx(-420.51, 256.53, 231.01, 90.01, -90.04, -90.02),2,2)
itp = posx(399.52-1, 121.94-1, 287.69+8, 90.34, 90, 90)
gtp = [
posx(168.79, 504.54, 249.76, 89.57, 90, 90),                # elc gripper
posx(-158.04, 505.79, 164.83+20, 90.68, 89.99, -90)]        # air agripper

# - motions
def mt1(p,g=0,d=[],mod=0,h=-1,z=0,a1=1500,a2=1000,b1=True,b2=False):
    tp = tr(pos[p] if isinstance(p,int) else p,[0,0,-z,0,0,0])
    ml(up(tp,mod,h),a=a1)
    if b2:
        return -1
    ml(tr(tp,[0,0,[-0.15,0][g],0,0,0]),a=a2,r=1)
    grip(g)
    if d:
        ad,val = d
        write(ad,val)
    if b1:
        ml(up(tp,mod,h),a=a1)

# 3. Main
def IT():
    mjx(up(itp,1,70))
    # sensing
    li = itli()
    li = li[4:]+li[0:4]
    for i in range(8):
        if li[i] == 10:
            for j in range(2):
                ml(up(itp,1,[20,10][j]),a=500)
                set_tool_digital_outputs([1,-2])
                wait(0.45)
                isg = not get_tool_digital_input(1)
                pack = [1,2][isg] if j else [0,3][isg]
                b = isg or j
                if b:
                    write(5,pack,b=False)
                grip(0)
                if b:
                    break
        else:
            wait(0.1)
        it(-1)
    # sorting
    wait(1)         # chill
    root = ''.join(['x' if i == 9 else str(i) for i in itli()])
    res = main(2,root)
    ml(itp)
    for i in range(len(res)):
        li = res[i][0]
        p = res[i][1]
        for j in range(2):
            n = 4 - list(itps).index(li[j])
            it(n)
            ml(up(itp,1,[0,5][j]))
            if j:
                rml(z=-5,acc=300)
            grip(not j)
            write(5,[0,p][j],b=False)
            if not j:
                ml(up(itp,1,70))
    it(4 - list(itps).index(4))
    rml(z=60)        
def A():
    global s,e,road1
    mjx(up(A1[2],1,70))
    m = root[T][::]
    li = info[T][0]
    s,e = info[T][1]
    for i in range(4):
        e =  main(0,m,s,-1,li)         # most close reader pos
        key = li.index(e)+1       # key number
        road2 = main(0,m,s,e,-1)        # in -> reader pos
        pos1 = read(20,2,2).index(10+key)       # key pos
        mt1(A1[pos1],1,[20+pos1,0],1,70)
        mt1(s,mod=1,h=70,b2=1)
        for j in road2:
            mt1(j,mod=1,h=5,b2=1)
        mt1(e,0,[e,10+key],1,5,a2 = 300,b1=0)
        rml(z=70)
        pos2 = m.index(str(key))         # door pos
        mt1(pos2,1,[pos2,0],1,70)
        mt1(A1[pos1],0,[20+pos1,key],1,70)
        li[key-1] = -1
        m = ''.join(['x' if i == e else '0' if i == pos2 else m[i] for i in range(20)])
    s,e = info[T][1]
    road1 = main(0,m,s,e,-1)
def B():
    global s,e,road1    
    posa = poss[0][0]
    m = root[T]
    li = info[T]
    ct = [0,0,0]        # need packs
    for i in range(4): 
        pack = m[i]
        ct[int(pack)-1] += li[i]
    for i in range(3):
        ct[i] -= m.count(str(i+1))    
    li1 = []
    for i in range(3):
        li1 += [i+1 for j in range(ct[i])]        
    for i in range(4):
        cht(n = 0)
        mjx(up(itp,1,70))
        ml(itp)
        pack = li1[i]       # pack
        gt(1,0)
        # get a pack at index
        it(4 - itli().index(pack))
        grip(1)
        write(5,0,b=0)
        rml(z=70)
        # pass in A
        mj([90,0,90,90,90,0])
        mt1(posa[s],mod=1,h=70,b2=1)
        for j in road1:
            mt1(posa[j],mod=1,h=5,b2=1)
            if j not in [s,e]:
                write(100+j,10,b=0)
                wait(0.05)
                write(100+j,0,b=0)
        rml(z=65)
        # going gantry and lay down a pack
        mj([90,0,90,90,90,0])
        mt1(gtp[0],0,[],1,70,b1=0)
        wait(0.3)
        set_tcp('tcp1')
        rml(b=-45,acc=300,t=0.5)
        grip(1)
        rml(z=50)
        rml(b=90,acc=300,t=0.8)
        rml(x=3,z=-75,t=0.3)
        grip(0)
        rml(z=76,t=0.8)
        set_tcp('tcp')
        # roading B
        gt(2)
        cht()
        mt1(gtp[1],1,[],1,10)
        pos = [j for j in range(i,16,4) if m[j] == '0'][0]
        mt1(pos,0,[pos,pack])
        m = ''.join([str(pack) if i == pos else m[i] for i in range(16)])
    # sorting
    res = main(1,m,li)
    cht(n = 1)
    for i in range(len(res)):
        r = res[i]
        s,e = r[0]
        p = r[1]
        mt1(s,1,[s,0])
        mt1(e,0,[e,p])
        
#write(30,1,b=False)
import time         # temp
time_start = time.time()        # temp

mj([90,0,90,90,90,0])
tool = 0
IT()        # index table sensing + sorting
for i in range(2):
    grip(0)
    T,pos = i,poss[tool][i]
    Run = [A,B][i]
    Run()
    
#write(30,1,b=False)
time_end = time.time() - time_start         # temp
minute,second = int(time_end // 60),int(time_end % 60)         # temp
tl('{}m {}s\n'.format(minute,second))         # temp