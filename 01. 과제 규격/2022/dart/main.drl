# 1. Header
tl = lambda *n:tp_log(' '.join(map(str,n)))
from collections import deque
from functools import lru_cache
drl_report_line(OFF)
set_motion_end(DR_CHECK_OFF)
set_tool('tool wei')
set_velx(1500); set_accx(3000)
set_velj(125); set_accj(250)
begin_blend(19)
ml,mj,aml,amj,t,wt = movel,movej,amovel,amovej,trans,wait
def mjx(pos):
    # r=get_distance(get_current_posx()[0],pos) / 20
    movejx(pos,sol=2)
rml = lambda h,t=None:ml([0,0,h,0,0,0],mod =1,t=t)
def arml(h,t=0.025):
    aml([0,0,h,0,0,0],mod=1)
    wait(t)
H = [50,15]
up = lambda pos,h=None:trans(pos,[0,0,h if h else H[isgrip],0,0,0])
# - device communication
ser=serial_open("COM")
def ts(ad,m=[],y=0,x=0):
    k='00'+['W','R'][y]+'SB06%DW'
    k=[ord(i) for i in k]
    n=len(m) if not y else y*x # 처리할 데이터 갯수
    ad = [0]*(3-len(str(ad))) + list(map(int,str(ad)))
    k+=[ord(str(abs(i))) for i in ad]
    k+=[ord(i) for i in '{:02X}'.format(n)]
    if not y:
        for i in m:
            if i<0:
                i+=2**16
            k+=[ord(j) for j in '{:04X}'.format(i)]
    ser.write([5]+k+[4])
    wait(0.05)
    k=ser.read(ser.inWaiting())
    if y:#읽기 일 때
        for i in range(0,y*x*4,4):
            v=int(k[10+i:14+i],16)
            if v&(1<<15):
                v-=2**16 
            m.append(v)
        return m if len(m) > 1 else m[0]        
# - pos
def ps(pos,y,x):
    s = y * x
    pos = [pos] * s
    for i in range(1,s):
        if i % x:
            pos[i] = trans(pos[i-1],[-40,0,0,0,0,0])
        else:
            pos[i] = trans(pos[i-x],[0,40,0,0,0,0])
    return pos            
Pos = [ps(posx(93.66, 396.24, 221.33, 180, 90, 90),4,4),
          ps(posx(92.6, 395.49, 205.2+20, 180, 90, -89.99),4,4)]
pos = Pos[0]
# - tool (0 : Gripper, 2 : Pneumatic_Gripper)
tool = 0   
def cht():
    global tool,pos
    tool = 1 - tool
    pos = Pos[tool]
    amj([0,0,0,0,0,-180 if tool else 180],mod=1)
    wait(1)

# - grip
isgrip = False
def grip(n):
    global isgrip
    isgrip = n
    if tool: # 공압 그리퍼
        if not n:
            wt(0.1)
        ts(70,[n])
    else: # 그리퍼
        set_tool_digital_outputs([1,-2] if n else [-1,2])
        wt(0.21 if n else 0.15)
 
# - motions
def mt(p,n,d=[]):
    pack = ts(p,[],1,1) if n else d[1]
    if tool:
        pass
    else:
        ml(pos[p], a=1500, r = [7.5,24][n])
        grip(n)
    if d:
        ad,val = d
        ts(ad,[val])
    return pack

# 2. Algorithm
def exc(m,s,e):
    m = list(m)
    m[s],m[e] = m[e],m[s]
    return [''.join(m),[e,s]]
@lru_cache(maxsize=None)
def aro(pos):
    res = []
    dy,dx = [-1,0,1,0],[0,1,0,-1]
    y,x = divmod(pos,sx)
    for i in range(4):
        ny,nx = y + dy[i],x + dx[i]
        if -1 < ny < sy and -1 < nx < sx:
            res.append(ny * sx + nx)
    return res   
def exp(n,m,pos=None):
    res = []
    for i in range(sy*sx) if n else [pos]:
        if (n and m[i] != '0') or i in fix:
            continue
        for j in aro(i):
            if m[j] == 'x' or j in fix:
                continue
            res.append(exc(m,i,j) if n else [j,j])
    return res  
def bfs(n,m,*a):
    if n:
        leaf,pos,pack = a
    else:
        s,e = a
    cur = m if n else s
    que = deque([cur])
    mkd,step = {cur:-1},{cur:-1}
    while 1:
        cur = que.popleft()
        if n:
            if cur == leaf or \
                (pos != -1 and cur[pos] == pack):
                    break
        elif cur == e:
            break
        for i,j in exp(n,cur if n else m,cur):
            if i not in mkd:
                que.append(i)
                mkd[i],step[i] = cur,j             
    mkd[-2] = cur
    path = [step[cur]]
    while mkd[cur] != -1:
        cur = mkd[cur]
        path.append(step[cur])
    return path[::-1][1:],mkd[-2]
def sort(m,leaf,e):
    res = []
    pack = leaf[e]
    s = m.index(pack)
    r = bfs(0,m,s,e)[0]
    for i in r:
        res0,m = bfs(1,m,leaf,i,pack)
        res += res0
    return res,m
def main(n,y,x,m,*a):
    global fix,sy,sx
    fix = []
    sy,sx = y,x
    res = []
    if n:
        leaf, = a
        li = [0,15,3,12,1,7,14,8,2,11,13,4,5,6,9,10]
        for i in li:
            if leaf[i] == '0':
                continue
            res0,m = sort(m,leaf,i)
            fix.append(i)
            res += res0
    else:
        s,e = a
        res = bfs(n,m,s,e)[0]
    return res
    
# 3. Main
#root = '0000cba987654321'
#leaf = '123456789abc0000'
#res = main(1,4,4,root,leaf)
res = [[7, 3], [11, 7], [15, 11], [3, 2], [7, 3], [11, 7], [2, 1], [3, 2], [7, 3], [1, 0], [2, 1], 
[3, 2], [6, 7], [5, 6], [1, 5], [2, 1], [6, 2], [5, 6], [4, 5], [0, 4], [1, 0], [5, 1], [9, 5], 
[8, 9], [12, 8], [7, 3], [6, 7], [5, 6], [4, 5], [8, 4], [9, 8], [5, 9], [4, 5], [7, 11], [3, 7], 
[2, 3], [1, 2], [5, 1], [6, 5], [2, 6], [1, 2], [11, 15], [7, 11], [3, 7], [2, 3], [6, 2], [10, 6], 
[14, 10], [2, 1], [6, 2], [10, 6], [5, 4], [1, 5], [2, 1], [6, 2], [5, 6], [1, 5], [2, 1], [6, 2], 
[5, 6], [4, 5], [8, 4], [9, 8], [5, 9], [4, 5], [6, 10], [5, 6], [10, 14], [11, 10], [7, 11], 
[6, 7], [9, 5], [13, 9], [5, 4], [9, 5], [5, 6], [6, 5], [2, 6], [10, 9], [6, 10], [5, 6], 
[6, 2], [14, 13], [15, 14], [11, 15], [10, 11], [14, 10], [10, 6], [6, 5], [5, 6], [4, 5], 
[9, 10], [5, 9], [6, 5], [5, 4], [9, 5], [13, 9], [5, 6], [9, 5], [10, 9], [15, 14], [14, 10]]

ts(0,[1,2,3,4,5,6,7,8,9,10,11,12,0,0,0,0][::-1]) # Hmi reset
grip(0)
mj([90,0,90,90,90,0])

for i in range(len(res)):
    s,e = res[i]
    if not i or s != res[i-1][1]:
        mjx(up(pos[s]))
        p = mt(s,1,[s,0])
    ml(up(pos[e]),a=1500)
    if i + 1 < len(res) and e == res[i+1][0]:
        continue
    mt(e,0,[e,p])
    rml(H[0])